complextype,method,NOP_method,CC_method,ATFD_method,FDP_method,CM_method,MAXNESTING_method,LOC_method,CYCLO_method,NMCS_method,NOLV_method,MaMCL_method,NOAV_method,LAA_method,FANOUT_method,CFNAMM_method,ATLD_method,CLNAMM_method,CINT_method,MeMCL_method,CDISP_method,NOII_type,NOAM_type,NOCS_type,NOM_type,NMO_type,ATFD_type,FANOUT_type,NOMNAMM_type,NOA_type,NIM_type,DIT_type,LOC_type,LOCNAMM_type,CFNAMM_type,TCC_type,NOPA_type,CBO_type,RFC_type,NOC_type,WMC_type,LCOM5_type,WOC_type,WMCNAMM_type,AMW_type,AMWNAMM_type,NOCS_package,NOMNAMM_package,NOI_package,LOC_package,NOM_package,NOPK_project,NOCS_project,NOI_project,NOM_project,NOMNAMM_project,LOC_project,isStatic_type,number_private_visibility_attributes,number_protected_visibility_attributes,number_package_visibility_attributes,num_final_attributes,num_static_attributes,number_public_visibility_methods,number_private_visibility_methods,number_protected_visibility_methods,number_package_visibility_methods,number_final_methods,number_abstract_methods,number_not_abstract_not_final_methods,number_static_methods,number_final_static_methods,number_final_not_static_methods,number_not_final_static_methods,number_not_final_not_static_methods,number_standard_design_methods,number_constructor_DefaultConstructor_methods,number_constructor_NotDefaultConstructor_methods,num_final_static_attributes,num_not_final_not_static_attributes,num_final_not_static_attributes,num_static_not_final_attributes,isStatic_method,is_feature_envy_count,is_feature_envy_sum,is_feature_envy_count_negative,is_feature_envy_count_positive,class_source_code,method_source,is_feature_envy,llm_user_msg,llm_classification
com.jasml.compiler.ConstantPoolGenerator,"private int addFieldNameAndType(String name, String type)",2,0,0,0,0,2,16,2,0,5,0,8,1.0,2,2,3,3,2,0,1.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,1,1,0,1,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","private int addFieldNameAndType(String name, String type) {
	int name_index, type_index, index;

	type = Util.toInnerType(type);
	index = lookupNameAndType(name + "" "" + type);
	if (index == -1) {
		name_index = addUtf8(name);
		type_index = addUtf8(type);
		ensureCapacity();
		items[count] = new Constant_NameAndType(name_index, type_index);
		nameTypes.put(name + "" "" + type, new Integer(count));
		index = count;
		count++;
	}
	return index;
}",True,"
*** SOURCE CODE: BEGIN ***
private int addFieldNameAndType(String name, String type) {
	int name_index, type_index, index;

	type = Util.toInnerType(type);
	index = lookupNameAndType(name + "" "" + type);
	if (index == -1) {
		name_index = addUtf8(name);
		type_index = addUtf8(type);
		ensureCapacity();
		items[count] = new Constant_NameAndType(name_index, type_index);
		nameTypes.put(name + "" "" + type, new Integer(count));
		index = count;
		count++;
	}
	return index;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 2
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 2
LOC_method = 16
CYCLO_method = 2
NMCS_method = 0
NOLV_method = 5
MaMCL_method = 0
NOAV_method = 8
LAA_method = 1.0
FANOUT_method = 2
CFNAMM_method = 2
ATLD_method = 3
CLNAMM_method = 3
CINT_method = 2
MeMCL_method = 0
CDISP_method = 1.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,"private int addMethodNameAndType(String name, String retType, String paras)",3,0,0,0,0,2,19,2,0,7,0,10,1.0,2,3,3,3,3,0,0.666666667,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,1,-1,1,0,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","private int addMethodNameAndType(String name, String retType, String paras) {
	int name_index, type_index, index;
	String type;

	retType = Util.toInnerType(retType);
	paras = Util.toInnerParameterTypes(paras);
	type = ""("" + paras + "")"" + retType;
	index = lookupNameAndType(name + type);
	if (index == -1) {
		name_index = addUtf8(name);
		type_index = addUtf8(type);
		ensureCapacity();
		items[count] = new Constant_NameAndType(name_index, type_index);
		nameTypes.put(name + type, new Integer(count));
		index = count;
		count++;
	}
	return index;
}",False,"
*** SOURCE CODE: BEGIN ***
private int addMethodNameAndType(String name, String retType, String paras) {
	int name_index, type_index, index;
	String type;

	retType = Util.toInnerType(retType);
	paras = Util.toInnerParameterTypes(paras);
	type = ""("" + paras + "")"" + retType;
	index = lookupNameAndType(name + type);
	if (index == -1) {
		name_index = addUtf8(name);
		type_index = addUtf8(type);
		ensureCapacity();
		items[count] = new Constant_NameAndType(name_index, type_index);
		nameTypes.put(name + type, new Integer(count));
		index = count;
		count++;
	}
	return index;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 3
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 2
LOC_method = 19
CYCLO_method = 2
NMCS_method = 0
NOLV_method = 7
MaMCL_method = 0
NOAV_method = 10
LAA_method = 1.0
FANOUT_method = 2
CFNAMM_method = 3
ATLD_method = 3
CLNAMM_method = 3
CINT_method = 3
MeMCL_method = 0
CDISP_method = 0.666666667
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,private int lookupDouble(double var),1,0,3,3,0,3,10,5,0,3,0,8,0.4,0,0,2,0,0,0,0.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,11,1,5,6,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","private int lookupDouble(double var) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
			return i;
		}
	}
	return -1;
}",True,"
*** SOURCE CODE: BEGIN ***
private int lookupDouble(double var) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
			return i;
		}
	}
	return -1;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 0
ATFD_method = 3
FDP_method = 3
CM_method = 0
MAXNESTING_method = 3
LOC_method = 10
CYCLO_method = 5
NMCS_method = 0
NOLV_method = 3
MaMCL_method = 0
NOAV_method = 8
LAA_method = 0.4
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,private int lookupFloat(float var),1,0,3,3,0,3,10,5,0,3,0,8,0.4,0,0,2,0,0,0,0.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,10,2,4,6,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","private int lookupFloat(float var) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
			return i;
		}
	}
	return -1;
}",True,"
*** SOURCE CODE: BEGIN ***
private int lookupFloat(float var) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
			return i;
		}
	}
	return -1;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 0
ATFD_method = 3
FDP_method = 3
CM_method = 0
MAXNESTING_method = 3
LOC_method = 10
CYCLO_method = 5
NMCS_method = 0
NOLV_method = 3
MaMCL_method = 0
NOAV_method = 8
LAA_method = 0.4
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,private int lookupInt(int var),1,0,3,3,0,3,10,5,0,3,0,8,0.4,0,0,2,0,0,0,0.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,10,2,4,6,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","private int lookupInt(int var) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
			return i;
		}
	}
	return -1;
}",True,"
*** SOURCE CODE: BEGIN ***
private int lookupInt(int var) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
			return i;
		}
	}
	return -1;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 0
ATFD_method = 3
FDP_method = 3
CM_method = 0
MAXNESTING_method = 3
LOC_method = 10
CYCLO_method = 5
NMCS_method = 0
NOLV_method = 3
MaMCL_method = 0
NOAV_method = 8
LAA_method = 0.4
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,private int lookupLong(long var),1,0,3,3,0,3,10,5,0,3,0,8,0.4,0,0,2,0,0,0,0.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,11,3,4,7,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","private int lookupLong(long var) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
			return i;
		}
	}
	return -1;
}",True,"
*** SOURCE CODE: BEGIN ***
private int lookupLong(long var) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
			return i;
		}
	}
	return -1;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 0
ATFD_method = 3
FDP_method = 3
CM_method = 0
MAXNESTING_method = 3
LOC_method = 10
CYCLO_method = 5
NMCS_method = 0
NOLV_method = 3
MaMCL_method = 0
NOAV_method = 8
LAA_method = 0.4
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,private int lookupUtf8(String s),1,0,3,3,0,3,10,5,0,3,0,8,0.4,0,0,2,0,0,0,0.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,11,-1,6,5,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","private int lookupUtf8(String s) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
			return i;
		}
	}
	return -1;
}",False,"
*** SOURCE CODE: BEGIN ***
private int lookupUtf8(String s) {
	ConstantPoolItem item;
	for (int i = 0; i < count; i++) {
		item = items[i];
		if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
			return i;
		}
	}
	return -1;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 0
ATFD_method = 3
FDP_method = 3
CM_method = 0
MAXNESTING_method = 3
LOC_method = 10
CYCLO_method = 5
NMCS_method = 0
NOLV_method = 3
MaMCL_method = 0
NOAV_method = 8
LAA_method = 0.4
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,private void ensureCapacity(),0,0,0,0,0,2,7,2,0,1,0,3,1.0,0,0,2,0,0,0,0.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,11,-3,7,4,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","private void ensureCapacity() {
	if (items.length < count + 3) {
		ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
		System.arraycopy(items, 0, ni, 0, items.length);
		items = ni;
	}
}",False,"
*** SOURCE CODE: BEGIN ***
private void ensureCapacity() {
	if (items.length < count + 3) {
		ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
		System.arraycopy(items, 0, ni, 0, items.length);
		items = ni;
	}
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 2
LOC_method = 7
CYCLO_method = 2
NMCS_method = 0
NOLV_method = 1
MaMCL_method = 0
NOAV_method = 3
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,public ConstantPool getConstantPool(),0,1,0,0,1,1,6,1,0,2,0,4,1.0,1,1,2,0,1,0,1.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,11,1,5,6,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","public ConstantPool getConstantPool() {
	ConstantPoolItem[] ret = new ConstantPoolItem[count];
	System.arraycopy(items, 0, ret, 0, count);
	ConstantPool cpl = new ConstantPool(ret);
	return cpl;
}",True,"
*** SOURCE CODE: BEGIN ***
public ConstantPool getConstantPool() {
	ConstantPoolItem[] ret = new ConstantPoolItem[count];
	System.arraycopy(items, 0, ret, 0, count);
	ConstantPool cpl = new ConstantPool(ret);
	return cpl;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 1
ATFD_method = 0
FDP_method = 0
CM_method = 1
MAXNESTING_method = 1
LOC_method = 6
CYCLO_method = 1
NMCS_method = 0
NOLV_method = 2
MaMCL_method = 0
NOAV_method = 4
LAA_method = 1.0
FANOUT_method = 1
CFNAMM_method = 1
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 1
MeMCL_method = 0
CDISP_method = 1.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,public int addClass(String className),1,1,0,0,5,2,16,2,0,3,0,6,1.0,2,2,3,3,2,0,1.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,1,1,0,1,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","public int addClass(String className) {
	int index = 0;
	className = Util.toInnerClassName(className);
	index = lookupClass(className);
	if (index == -1) {
		// add the class
		int class_name_index = addUtf8(className);
		ensureCapacity();
		items[count] = new Constant_Class(class_name_index);
		classes.put(className, new Integer(count));
		return count++;
	} else {
		return index;
	}
}",True,"
*** SOURCE CODE: BEGIN ***
public int addClass(String className) {
	int index = 0;
	className = Util.toInnerClassName(className);
	index = lookupClass(className);
	if (index == -1) {
		// add the class
		int class_name_index = addUtf8(className);
		ensureCapacity();
		items[count] = new Constant_Class(class_name_index);
		classes.put(className, new Integer(count));
		return count++;
	} else {
		return index;
	}
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 1
ATFD_method = 0
FDP_method = 0
CM_method = 5
MAXNESTING_method = 2
LOC_method = 16
CYCLO_method = 2
NMCS_method = 0
NOLV_method = 3
MaMCL_method = 0
NOAV_method = 6
LAA_method = 1.0
FANOUT_method = 2
CFNAMM_method = 2
ATLD_method = 3
CLNAMM_method = 3
CINT_method = 2
MeMCL_method = 0
CDISP_method = 1.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,public int addDouble(double var),1,1,0,0,3,2,10,2,0,2,0,4,1.0,1,1,2,2,1,0,1.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,1,1,0,1,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","public int addDouble(double var) {
	int index = lookupDouble(var);
	if (index == -1) {
		ensureCapacity();
		items[count] = new Constant_Double(var);
		index = count;
		count = count + 2;
	}
	return index;
}",True,"
*** SOURCE CODE: BEGIN ***
public int addDouble(double var) {
	int index = lookupDouble(var);
	if (index == -1) {
		ensureCapacity();
		items[count] = new Constant_Double(var);
		index = count;
		count = count + 2;
	}
	return index;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 1
ATFD_method = 0
FDP_method = 0
CM_method = 3
MAXNESTING_method = 2
LOC_method = 10
CYCLO_method = 2
NMCS_method = 0
NOLV_method = 2
MaMCL_method = 0
NOAV_method = 4
LAA_method = 1.0
FANOUT_method = 1
CFNAMM_method = 1
ATLD_method = 2
CLNAMM_method = 2
CINT_method = 1
MeMCL_method = 0
CDISP_method = 1.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,public int addFloat(float var),1,1,0,0,2,2,10,2,0,2,0,4,1.0,1,1,2,2,1,0,1.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,1,1,0,1,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","public int addFloat(float var) {
	int index = lookupFloat(var);
	if (index == -1) {
		ensureCapacity();
		items[count] = new Constant_Float(var);
		index = count;
		count++;
	}
	return index;
}",True,"
*** SOURCE CODE: BEGIN ***
public int addFloat(float var) {
	int index = lookupFloat(var);
	if (index == -1) {
		ensureCapacity();
		items[count] = new Constant_Float(var);
		index = count;
		count++;
	}
	return index;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 1
ATFD_method = 0
FDP_method = 0
CM_method = 2
MAXNESTING_method = 2
LOC_method = 10
CYCLO_method = 2
NMCS_method = 0
NOLV_method = 2
MaMCL_method = 0
NOAV_method = 4
LAA_method = 1.0
FANOUT_method = 1
CFNAMM_method = 1
ATLD_method = 2
CLNAMM_method = 2
CINT_method = 1
MeMCL_method = 0
CDISP_method = 1.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.ConstantPoolGenerator,public int addInteger(int var),1,1,0,0,2,2,10,2,0,2,0,4,1.0,1,1,2,2,1,0,1.0,0,1,0,25,0,11,14,24,6,0,1,312,304,16,1,0,15,41,0,62,0.701388889,0.923076923,61,2.48,2.541666667,8,100,1,2639,109,4,48,1,245,233,6694,0,6,0,0,0,0,13,12,0,0,0,0,25,1,0,0,1,24,23,0,1,0,6,0,0,0,1,1,0,1,"/*
 * Author jyang
 * Created on 2006-4-7 11:08:44
 */
package com.jasml.compiler;

import java.util.HashMap;

import com.jasml.classes.*;
import com.jasml.helper.Util;


public class ConstantPoolGenerator {
	private ConstantPoolItem[] items;

	private int count = 1;

	private HashMap classes = new HashMap();

	private HashMap nameTypes = new HashMap();

	private HashMap mifRef = new HashMap(); // methodRef, fieldRef, interfaceMethodRef

	private HashMap strings = new HashMap();

	public ConstantPoolGenerator() {
		items = new ConstantPoolItem[30];
		items[0] = new ConstantPoolItem((byte) 0);
	}

	public ConstantPool getConstantPool() {
		ConstantPoolItem[] ret = new ConstantPoolItem[count];
		System.arraycopy(items, 0, ret, 0, count);
		ConstantPool cpl = new ConstantPool(ret);
		return cpl;
	}

	/**
	 * this can be used to add a Constant_Class entry into constant pool.
	 * a constant class could be of a class type( like java/lang/Object),
	 * or of an array type of class(like [Ljava/lang/Object;),
	 * or array type of a primitive type(like [[I)
	 * @param className can be Strings like java.lang.Object, java.lang.Object[][], int[][].
	 * @return
	 */
	public int addClass(String className) {
		int index = 0;
		className = Util.toInnerClassName(className);
		index = lookupClass(className);
		if (index == -1) {
			// add the class
			int class_name_index = addUtf8(className);
			ensureCapacity();
			items[count] = new Constant_Class(class_name_index);
			classes.put(className, new Integer(count));
			return count++;
		} else {
			return index;
		}

	}

	public int addDouble(double var) {
		int index = lookupDouble(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Double(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addFieldref(String name, String className, String type) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addFieldNameAndType(name, type);
		index = lookupMIFref(""F_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Fieldref(class_index, name_and_type_index);
			mifRef.put(""F_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addFloat(float var) {
		int index = lookupFloat(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Float(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInteger(int var) {
		int index = lookupInt(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Integer(var);
			index = count;
			count++;
		}
		return index;
	}

	public int addInterfaceMethodref(String name, String interfaceName, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(interfaceName);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""I_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_InterfaceMethodref(class_index, name_and_type_index);
			mifRef.put(""I_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addLong(long var) {
		int index = lookupLong(var);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Long(var);
			index = count;
			count = count + 2;
		}
		return index;
	}

	public int addMethodref(String name, String className, String retType, String paras) {
		int class_index, name_and_type_index, index;
		class_index = addClass(className);
		name_and_type_index = addMethodNameAndType(name, retType, paras);
		index = lookupMIFref(""M_"" + class_index + ""_"" + name_and_type_index);
		if (index == -1) {
			ensureCapacity();
			items[count] = new Constant_Methodref(class_index, name_and_type_index);
			mifRef.put(""M_"" + class_index + ""_"" + name_and_type_index, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	/*
	 * lookup existing field, method, interfaceMethod references
	 * in the format of [X]_[class_index]_[name_and_type_index]
	 * for method_ref X='M', field_ref X='F', interfaceMethod_ref X='I'
	 */
	private int lookupMIFref(String s) {
		Object obj = mifRef.get(s);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int addFieldNameAndType(String name, String type) {
		int name_index, type_index, index;

		type = Util.toInnerType(type);
		index = lookupNameAndType(name + "" "" + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + "" "" + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	private int addMethodNameAndType(String name, String retType, String paras) {
		int name_index, type_index, index;
		String type;

		retType = Util.toInnerType(retType);
		paras = Util.toInnerParameterTypes(paras);
		type = ""("" + paras + "")"" + retType;
		index = lookupNameAndType(name + type);
		if (index == -1) {
			name_index = addUtf8(name);
			type_index = addUtf8(type);
			ensureCapacity();
			items[count] = new Constant_NameAndType(name_index, type_index);
			nameTypes.put(name + type, new Integer(count));
			index = count;
			count++;
		}
		return index;
	}

	public int addString(String s) {
		int ret = lookupString(s);
		if (ret == -1) {
			ConstantPoolItem item = new Constant_String(addUtf8(s));
			ensureCapacity();
			ret = count;
			items[count] = item;
			strings.put(s, new Integer(ret));
			count ++;
		}
		return ret;
	}

	private int lookupString(String s) {
		Object obj = strings.get(s);
		if (obj != null) {
			return ((Integer) obj).intValue();
		}
		return -1;
	}

	public int addUtf8(String s) {
		int ret = lookupUtf8(s);
		if (ret == -1) {
			ensureCapacity();
			ConstantPoolItem item = new Constant_Utf8(s);
			ret = count;
			items[count++] = item;
		}
		return ret;
	}

	private int lookupUtf8(String s) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Utf8 && ((Constant_Utf8) item).bytes.equals(s) == true) {
				return i;
			}
		}
		return -1;
	}

	private int lookupClass(String className) {
		Object obj = classes.get(className);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}
	}

	private int lookupNameAndType(String nameType) {
		Object obj = nameTypes.get(nameType);
		if (obj == null) {
			return -1;
		} else {
			return ((Integer) obj).intValue();
		}

	}

	private int lookupDouble(double var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Double && ((Constant_Double) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupInt(int var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Integer && ((Constant_Integer) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupFloat(float var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Float && ((Constant_Float) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private int lookupLong(long var) {
		ConstantPoolItem item;
		for (int i = 0; i < count; i++) {
			item = items[i];
			if (item != null && item.tag == Constants.CONSTANT_Long && ((Constant_Long) item).value == var) {
				return i;
			}
		}
		return -1;
	}

	private void ensureCapacity() {
		if (items.length < count + 3) {
			ConstantPoolItem[] ni = new ConstantPoolItem[items.length + 20];
			System.arraycopy(items, 0, ni, 0, items.length);
			items = ni;
		}
	}

	public static void main(String[] args) {
		ConstantPoolGenerator gen = new ConstantPoolGenerator();
		System.out.println(gen.addString("".""));
		System.out.println(gen.addString("".""));

	}
}","public int addInteger(int var) {
	int index = lookupInt(var);
	if (index == -1) {
		ensureCapacity();
		items[count] = new Constant_Integer(var);
		index = count;
		count++;
	}
	return index;
}",True,"
*** SOURCE CODE: BEGIN ***
public int addInteger(int var) {
	int index = lookupInt(var);
	if (index == -1) {
		ensureCapacity();
		items[count] = new Constant_Integer(var);
		index = count;
		count++;
	}
	return index;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 1
ATFD_method = 0
FDP_method = 0
CM_method = 2
MAXNESTING_method = 2
LOC_method = 10
CYCLO_method = 2
NMCS_method = 0
NOLV_method = 2
MaMCL_method = 0
NOAV_method = 4
LAA_method = 1.0
FANOUT_method = 1
CFNAMM_method = 1
ATLD_method = 2
CLNAMM_method = 2
CINT_method = 1
MeMCL_method = 0
CDISP_method = 1.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 25
NMO_type = 0
ATFD_type = 11
FANOUT_type = 14
NOMNAMM_type = 24
NOA_type = 6
NIM_type = 0
DIT_type = 1
LOC_type = 312
LOCNAMM_type = 304
CFNAMM_type = 16
TCC_type = 1
NOPA_type = 0
CBO_type = 15
RFC_type = 41
NOC_type = 0
WMC_type = 62
LCOM5_type = 0.701388889
WOC_type = 0.923076923
WMCNAMM_type = 61
AMW_type = 2.48
AMWNAMM_type = 2.541666667
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 6
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 13
number_private_visibility_methods = 12
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 25
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 24
number_standard_design_methods = 23
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 6
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.JavaClassDumpper,private void dumpClassHeader() throws IOException,0,0,3,1,0,1,5,1,0,0,0,5,0.4,0,0,2,0,0,0,0.0,0,0,0,10,0,96,1,10,3,0,1,243,243,1,1,0,28,12,0,47,0.481481481,1.0,47,4.7,4.7,8,100,1,2639,109,4,48,1,245,233,6694,0,0,0,3,0,0,2,8,0,0,0,0,10,0,0,0,0,10,9,0,1,0,3,0,0,0,77,7,35,42,"/*
 * Author jyang
 * Created on 2006-4-12 17:36:22
 */
package com.jasml.compiler;

import java.io.*;

import com.jasml.classes.*;


public class JavaClassDumpper {
	DataOutputStream out = null;

	JavaClass clazz = null;

	File destFile = null;

	public JavaClassDumpper(JavaClass clazz, File destFile) {
		this.destFile = destFile;
		this.clazz = clazz;
	}

	public void dump() throws IOException {
		out = new DataOutputStream(new FileOutputStream(destFile));
		dumpClassHeader();
		dumpConstantPool();
		dumpClassInfo();
		dumpInterfaces();
		dumpFields();
		dumpMethods();
		dumpClassAttributes();
		out.close();
	}

	/**
	 * dump the magic, minor and major version
	 * 
	 * @throws IOException
	 */
	private void dumpClassHeader() throws IOException {
		out.writeInt(clazz.magic);
		out.writeShort(clazz.minor_version);
		out.writeShort(clazz.major_version);
	}

	private void dumpConstantPool() throws IOException {
		ConstantPool pool = clazz.constantPool;
		ConstantPoolItem pi = null;
		int poolCount = pool.getConstantPoolCount();
		out.writeShort(poolCount);
		for (int i = 1; i < poolCount; i++) {
			pi = pool.getConstant(i);
			out.writeByte(pi.tag);
			switch (pi.tag) {
			case Constants.CONSTANT_Utf8:
				out.writeUTF(((Constant_Utf8) pi).bytes);
				break;
			case Constants.CONSTANT_Integer:
				out.writeInt(((Constant_Integer) pi).value);
				break;
			case Constants.CONSTANT_Float:
				out.writeFloat(((Constant_Float) pi).value);
				break;
			case Constants.CONSTANT_Long:
				out.writeLong(((Constant_Long) pi).value);
				i++;
				break;
			case Constants.CONSTANT_Double:
				out.writeDouble(((Constant_Double) pi).value);
				i++;
				break;
			case Constants.CONSTANT_Class:
				out.writeShort(((Constant_Class) pi).name_index);
				break;
			case Constants.CONSTANT_Fieldref:
				out.writeShort(((Constant_Fieldref) pi).class_index);
				out.writeShort(((Constant_Fieldref) pi).name_and_type_index);
				break;
			case Constants.CONSTANT_String:
				out.writeShort(((Constant_String) pi).string_index);
				break;
			case Constants.CONSTANT_Methodref:
				out.writeShort(((Constant_Methodref) pi).class_index);
				out.writeShort(((Constant_Methodref) pi).name_and_type_index);
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				out.writeShort(((Constant_InterfaceMethodref) pi).class_index);
				out.writeShort(((Constant_InterfaceMethodref) pi).name_and_type_index);
				break;
			case Constants.CONSTANT_NameAndType:
				out.writeShort(((Constant_NameAndType) pi).name_index);
				out.writeShort(((Constant_NameAndType) pi).descriptor_index);
				break;
			default: // TODO: throws exceptoin
				int x = 9 / 0;
			}
		}
	}

	private void dumpClassInfo() throws IOException {
		out.writeShort(clazz.access_flags);
		out.writeShort(clazz.this_class);
		out.writeShort(clazz.super_class);
	}

	/**
	 * dump interfaces implemented by this class
	 * 
	 * @throws IOException
	 */

	private void dumpInterfaces() throws IOException {
		out.writeShort(clazz.interfaces_count);
		for (int i = 0; i < clazz.interfaces_count; i++) {
			out.writeShort(clazz.interfaces[i]);
		}
	}

	private void dumpFields() throws IOException {
		Field field = null;
		out.writeShort(clazz.fields_count);
		for (int i = 0; i < clazz.fields_count; i++) {
			field = clazz.fields[i];
			out.writeShort(field.access_flags);
			out.writeShort(field.name_index);
			out.writeShort(field.descriptor_index);
			out.writeShort(field.attributes_count);
			for (int j = 0; j < field.attributes_count; j++) {
				dumpAttribute(field.attributes[j]);
			}
		}
	}

	private void dumpMethods() throws IOException {
		Method method = null;
		out.writeShort(clazz.methods_count);
		for (int i = 0; i < clazz.methods_count; i++) {
			method = clazz.methods[i];
			out.writeShort(method.access_flags);
			out.writeShort(method.name_index);
			out.writeShort(method.descriptor_index);
			out.writeShort(method.attributes_count);
			for (int j = 0; j < method.attributes_count; j++) {
				dumpAttribute(method.attributes[j]);
			}
		}
	}

	private void dumpClassAttributes() throws IOException {
		out.writeShort(clazz.attributes_count);
		for (int i = 0; i < clazz.attributes_count; i++) {
			dumpAttribute(clazz.attributes[i]);
		}
	}

	private void dumpAttribute(Attribute attribute) throws IOException {
		out.writeShort(attribute.attribute_name_index);
		out.writeInt(attribute.attribute_length);

		switch (attribute.attribute_tag) {
		case Constants.ATTRIBUTE_SourceFile:
			out.writeShort(((Attribute_SourceFile) attribute).sourcefile_index);
			break;

		case Constants.ATTRIBUTE_ConstantValue:
			out.writeShort(((Attribute_ConstantValue) attribute).constant_value_index);
			break;

		case Constants.ATTRIBUTE_Code:
			Attribute_Code code = (Attribute_Code) attribute;
			byte[][] operands;

			out.writeShort(code.max_stack);
			out.writeShort(code.max_locals);
			out.writeInt(code.code_length);
			// codes
			Attribute_Code.Opcode op;
			for (int i = 0; i < code.codes.length; i++) {
				op = code.codes[i];
				out.writeByte(op.opcode);

				operands = op.operands;
				if (operands != null && operands.length != 0) {
					for (int j = 0; j < operands.length; j++) {
						if (operands[j] != null) {
							out.write(operands[j]);
						}
					}
				}
			}
			out.writeShort(code.exception_table_length);
			// exception table
			Attribute_Code.ExceptionTableItem exc;
			for (int i = 0; i < code.exception_table_length; i++) {
				exc = code.exception_table[i];
				out.writeShort(exc.start_pc);
				out.writeShort(exc.end_pc);
				out.writeShort(exc.handler_pc);
				out.writeShort(exc.catch_type);
			}

			// attributes
			out.writeShort(code.attributes_count);
			for (int i = 0; i < code.attributes_count; i++) {
				dumpAttribute(code.attributes[i]);
			}
			break;
		case Constants.ATTRIBUTE_Exceptions:
			Attribute_Exceptions excep = (Attribute_Exceptions) attribute;
			out.writeShort(excep.number_of_exceptions);
			for (int i = 0; i < excep.number_of_exceptions; i++) {
				out.writeShort(excep.exception_index_table[i]);
			}
			break;
		case Constants.ATTRIBUTE_InnerClasses:
			Attribute_InnerClasses innerClasses = (Attribute_InnerClasses) attribute;
			Attribute_InnerClasses.InnerClass cla;
			out.writeShort(innerClasses.number_of_classes);
			for (int i = 0; i < innerClasses.number_of_classes; i++) {
				cla = innerClasses.innerClasses[i];
				out.writeShort(cla.inner_class_info_index);
				out.writeShort(cla.outer_class_info_index);
				out.writeShort(cla.inner_name_index);
				out.writeShort(cla.inner_class_access_flags);
			}
			break;

		case Constants.ATTRIBUTE_Deprecated:
		case Constants.ATTRIBUTE_Synthetic:
			// nothing to write
			break;

		case Constants.ATTRIBUTE_LineNumberTable:
			// TODO: not supported yet
			break;

		case Constants.ATTRIBUTE_LocalVariableTable:
			Attribute_LocalVariableTable lvt = (Attribute_LocalVariableTable) attribute;
			Attribute_LocalVariableTable.LocalVariable lv;
			out.writeShort(lvt.local_variable_table_length);
			for (int i = 0; i < lvt.local_variable_table_length; i++) {
				lv = lvt.local_variable_table[i];
				out.writeShort(lv.start_pc);
				out.writeShort(lv.length);
				out.writeShort(lv.name_index);
				out.writeShort(lv.descriptor_index);
				out.writeShort(lv.index);
			}
			break;
		}
	}

}","private void dumpClassHeader() throws IOException {
	out.writeInt(clazz.magic);
	out.writeShort(clazz.minor_version);
	out.writeShort(clazz.major_version);
}",True,"
*** SOURCE CODE: BEGIN ***
private void dumpClassHeader() throws IOException {
	out.writeInt(clazz.magic);
	out.writeShort(clazz.minor_version);
	out.writeShort(clazz.major_version);
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 3
FDP_method = 1
CM_method = 0
MAXNESTING_method = 1
LOC_method = 5
CYCLO_method = 1
NMCS_method = 0
NOLV_method = 0
MaMCL_method = 0
NOAV_method = 5
LAA_method = 0.4
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 10
NMO_type = 0
ATFD_type = 96
FANOUT_type = 1
NOMNAMM_type = 10
NOA_type = 3
NIM_type = 0
DIT_type = 1
LOC_type = 243
LOCNAMM_type = 243
CFNAMM_type = 1
TCC_type = 1
NOPA_type = 0
CBO_type = 28
RFC_type = 12
NOC_type = 0
WMC_type = 47
LCOM5_type = 0.481481481
WOC_type = 1.0
WMCNAMM_type = 47
AMW_type = 4.7
AMWNAMM_type = 4.7
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 3
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 2
number_private_visibility_methods = 8
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 10
number_static_methods = 0
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 0
number_not_final_not_static_methods = 10
number_standard_design_methods = 9
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 3
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.compiler.JavaClassDumpper,private void dumpClassInfo() throws IOException,0,0,3,1,0,1,5,1,0,0,0,5,0.4,0,0,2,0,0,0,0.0,0,0,0,10,0,96,1,10,3,0,1,243,243,1,1,0,28,12,0,47,0.481481481,1.0,47,4.7,4.7,8,100,1,2639,109,4,48,1,245,233,6694,0,0,0,3,0,0,2,8,0,0,0,0,10,0,0,0,0,10,9,0,1,0,3,0,0,0,74,4,35,39,"/*
 * Author jyang
 * Created on 2006-4-12 17:36:22
 */
package com.jasml.compiler;

import java.io.*;

import com.jasml.classes.*;


public class JavaClassDumpper {
	DataOutputStream out = null;

	JavaClass clazz = null;

	File destFile = null;

	public JavaClassDumpper(JavaClass clazz, File destFile) {
		this.destFile = destFile;
		this.clazz = clazz;
	}

	public void dump() throws IOException {
		out = new DataOutputStream(new FileOutputStream(destFile));
		dumpClassHeader();
		dumpConstantPool();
		dumpClassInfo();
		dumpInterfaces();
		dumpFields();
		dumpMethods();
		dumpClassAttributes();
		out.close();
	}

	/**
	 * dump the magic, minor and major version
	 * 
	 * @throws IOException
	 */
	private void dumpClassHeader() throws IOException {
		out.writeInt(clazz.magic);
		out.writeShort(clazz.minor_version);
		out.writeShort(clazz.major_version);
	}

	private void dumpConstantPool() throws IOException {
		ConstantPool pool = clazz.constantPool;
		ConstantPoolItem pi = null;
		int poolCount = pool.getConstantPoolCount();
		out.writeShort(poolCount);
		for (int i = 1; i < poolCount; i++) {
			pi = pool.getConstant(i);
			out.writeByte(pi.tag);
			switch (pi.tag) {
			case Constants.CONSTANT_Utf8:
				out.writeUTF(((Constant_Utf8) pi).bytes);
				break;
			case Constants.CONSTANT_Integer:
				out.writeInt(((Constant_Integer) pi).value);
				break;
			case Constants.CONSTANT_Float:
				out.writeFloat(((Constant_Float) pi).value);
				break;
			case Constants.CONSTANT_Long:
				out.writeLong(((Constant_Long) pi).value);
				i++;
				break;
			case Constants.CONSTANT_Double:
				out.writeDouble(((Constant_Double) pi).value);
				i++;
				break;
			case Constants.CONSTANT_Class:
				out.writeShort(((Constant_Class) pi).name_index);
				break;
			case Constants.CONSTANT_Fieldref:
				out.writeShort(((Constant_Fieldref) pi).class_index);
				out.writeShort(((Constant_Fieldref) pi).name_and_type_index);
				break;
			case Constants.CONSTANT_String:
				out.writeShort(((Constant_String) pi).string_index);
				break;
			case Constants.CONSTANT_Methodref:
				out.writeShort(((Constant_Methodref) pi).class_index);
				out.writeShort(((Constant_Methodref) pi).name_and_type_index);
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				out.writeShort(((Constant_InterfaceMethodref) pi).class_index);
				out.writeShort(((Constant_InterfaceMethodref) pi).name_and_type_index);
				break;
			case Constants.CONSTANT_NameAndType:
				out.writeShort(((Constant_NameAndType) pi).name_index);
				out.writeShort(((Constant_NameAndType) pi).descriptor_index);
				break;
			default: // TODO: throws exceptoin
				int x = 9 / 0;
			}
		}
	}

	private void dumpClassInfo() throws IOException {
		out.writeShort(clazz.access_flags);
		out.writeShort(clazz.this_class);
		out.writeShort(clazz.super_class);
	}

	/**
	 * dump interfaces implemented by this class
	 * 
	 * @throws IOException
	 */

	private void dumpInterfaces() throws IOException {
		out.writeShort(clazz.interfaces_count);
		for (int i = 0; i < clazz.interfaces_count; i++) {
			out.writeShort(clazz.interfaces[i]);
		}
	}

	private void dumpFields() throws IOException {
		Field field = null;
		out.writeShort(clazz.fields_count);
		for (int i = 0; i < clazz.fields_count; i++) {
			field = clazz.fields[i];
			out.writeShort(field.access_flags);
			out.writeShort(field.name_index);
			out.writeShort(field.descriptor_index);
			out.writeShort(field.attributes_count);
			for (int j = 0; j < field.attributes_count; j++) {
				dumpAttribute(field.attributes[j]);
			}
		}
	}

	private void dumpMethods() throws IOException {
		Method method = null;
		out.writeShort(clazz.methods_count);
		for (int i = 0; i < clazz.methods_count; i++) {
			method = clazz.methods[i];
			out.writeShort(method.access_flags);
			out.writeShort(method.name_index);
			out.writeShort(method.descriptor_index);
			out.writeShort(method.attributes_count);
			for (int j = 0; j < method.attributes_count; j++) {
				dumpAttribute(method.attributes[j]);
			}
		}
	}

	private void dumpClassAttributes() throws IOException {
		out.writeShort(clazz.attributes_count);
		for (int i = 0; i < clazz.attributes_count; i++) {
			dumpAttribute(clazz.attributes[i]);
		}
	}

	private void dumpAttribute(Attribute attribute) throws IOException {
		out.writeShort(attribute.attribute_name_index);
		out.writeInt(attribute.attribute_length);

		switch (attribute.attribute_tag) {
		case Constants.ATTRIBUTE_SourceFile:
			out.writeShort(((Attribute_SourceFile) attribute).sourcefile_index);
			break;

		case Constants.ATTRIBUTE_ConstantValue:
			out.writeShort(((Attribute_ConstantValue) attribute).constant_value_index);
			break;

		case Constants.ATTRIBUTE_Code:
			Attribute_Code code = (Attribute_Code) attribute;
			byte[][] operands;

			out.writeShort(code.max_stack);
			out.writeShort(code.max_locals);
			out.writeInt(code.code_length);
			// codes
			Attribute_Code.Opcode op;
			for (int i = 0; i < code.codes.length; i++) {
				op = code.codes[i];
				out.writeByte(op.opcode);

				operands = op.operands;
				if (operands != null && operands.length != 0) {
					for (int j = 0; j < operands.length; j++) {
						if (operands[j] != null) {
							out.write(operands[j]);
						}
					}
				}
			}
			out.writeShort(code.exception_table_length);
			// exception table
			Attribute_Code.ExceptionTableItem exc;
			for (int i = 0; i < code.exception_table_length; i++) {
				exc = code.exception_table[i];
				out.writeShort(exc.start_pc);
				out.writeShort(exc.end_pc);
				out.writeShort(exc.handler_pc);
				out.writeShort(exc.catch_type);
			}

			// attributes
			out.writeShort(code.attributes_count);
			for (int i = 0; i < code.attributes_count; i++) {
				dumpAttribute(code.attributes[i]);
			}
			break;
		case Constants.ATTRIBUTE_Exceptions:
			Attribute_Exceptions excep = (Attribute_Exceptions) attribute;
			out.writeShort(excep.number_of_exceptions);
			for (int i = 0; i < excep.number_of_exceptions; i++) {
				out.writeShort(excep.exception_index_table[i]);
			}
			break;
		case Constants.ATTRIBUTE_InnerClasses:
			Attribute_InnerClasses innerClasses = (Attribute_InnerClasses) attribute;
			Attribute_InnerClasses.InnerClass cla;
			out.writeShort(innerClasses.number_of_classes);
			for (int i = 0; i < innerClasses.number_of_classes; i++) {
				cla = innerClasses.innerClasses[i];
				out.writeShort(cla.inner_class_info_index);
				out.writeShort(cla.outer_class_info_index);
				out.writeShort(cla.inner_name_index);
				out.writeShort(cla.inner_class_access_flags);
			}
			break;

		case Constants.ATTRIBUTE_Deprecated:
		case Constants.ATTRIBUTE_Synthetic:
			// nothing to write
			break;

		case Constants.ATTRIBUTE_LineNumberTable:
			// TODO: not supported yet
			break;

		case Constants.ATTRIBUTE_LocalVariableTable:
			Attribute_LocalVariableTable lvt = (Attribute_LocalVariableTable) attribute;
			Attribute_LocalVariableTable.LocalVariable lv;
			out.writeShort(lvt.local_variable_table_length);
			for (int i = 0; i < lvt.local_variable_table_length; i++) {
				lv = lvt.local_variable_table[i];
				out.writeShort(lv.start_pc);
				out.writeShort(lv.length);
				out.writeShort(lv.name_index);
				out.writeShort(lv.descriptor_index);
				out.writeShort(lv.index);
			}
			break;
		}
	}

}","private void dumpClassInfo() throws IOException {
	out.writeShort(clazz.access_flags);
	out.writeShort(clazz.this_class);
	out.writeShort(clazz.super_class);
}",True,"
*** SOURCE CODE: BEGIN ***
private void dumpClassInfo() throws IOException {
	out.writeShort(clazz.access_flags);
	out.writeShort(clazz.this_class);
	out.writeShort(clazz.super_class);
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 3
FDP_method = 1
CM_method = 0
MAXNESTING_method = 1
LOC_method = 5
CYCLO_method = 1
NMCS_method = 0
NOLV_method = 0
MaMCL_method = 0
NOAV_method = 5
LAA_method = 0.4
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 10
NMO_type = 0
ATFD_type = 96
FANOUT_type = 1
NOMNAMM_type = 10
NOA_type = 3
NIM_type = 0
DIT_type = 1
LOC_type = 243
LOCNAMM_type = 243
CFNAMM_type = 1
TCC_type = 1
NOPA_type = 0
CBO_type = 28
RFC_type = 12
NOC_type = 0
WMC_type = 47
LCOM5_type = 0.481481481
WOC_type = 1.0
WMCNAMM_type = 47
AMW_type = 4.7
AMWNAMM_type = 4.7
NOCS_package = 8
NOMNAMM_package = 100
NOI_package = 1
LOC_package = 2639
NOM_package = 109
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 3
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 2
number_private_visibility_methods = 8
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 10
number_static_methods = 0
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 0
number_not_final_not_static_methods = 10
number_standard_design_methods = 9
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 0
num_not_final_not_static_attributes = 3
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,private void readAccess_flags() throws IOException,0,0,0,0,0,1,3,1,0,0,0,2,1.0,0,0,2,0,0,0,0.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,1,-1,1,0,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","private void readAccess_flags() throws IOException {
	access_flags = (short) in.readUnsignedShort();
}",False,"
*** SOURCE CODE: BEGIN ***
private void readAccess_flags() throws IOException {
	access_flags = (short) in.readUnsignedShort();
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 1
LOC_method = 3
CYCLO_method = 1
NMCS_method = 0
NOLV_method = 0
MaMCL_method = 0
NOAV_method = 2
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,private void readAttributes() throws IOException,0,0,0,0,0,3,11,3,0,1,0,4,1.0,0,0,3,2,0,0,0.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,2,2,0,2,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
}",True,"
*** SOURCE CODE: BEGIN ***
private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 3
LOC_method = 11
CYCLO_method = 3
NMCS_method = 0
NOLV_method = 1
MaMCL_method = 0
NOAV_method = 4
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 3
CLNAMM_method = 2
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,private void readConstant_Pool_Count() throws IOException,0,0,11,1,0,2,48,13,0,3,0,17,0.214285714,12,12,3,0,12,0,1.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,1,-1,1,0,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","private void readConstant_Pool_Count() throws IOException {
	prt(""#constant pool"");
	constant_Pool_Count = (short) in.readUnsignedShort();
}",False,"
*** SOURCE CODE: BEGIN ***
private void readConstant_Pool_Count() throws IOException {
	prt(""#constant pool"");
	constant_Pool_Count = (short) in.readUnsignedShort();
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 11
FDP_method = 1
CM_method = 0
MAXNESTING_method = 2
LOC_method = 48
CYCLO_method = 13
NMCS_method = 0
NOLV_method = 3
MaMCL_method = 0
NOAV_method = 17
LAA_method = 0.214285714
FANOUT_method = 12
CFNAMM_method = 12
ATLD_method = 3
CLNAMM_method = 0
CINT_method = 12
MeMCL_method = 0
CDISP_method = 1.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,private void readFields() throws IOException,0,0,0,0,0,3,11,3,0,1,0,4,1.0,0,0,3,2,0,0,0.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,2,2,0,2,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","private void readFields() throws IOException {
	prt(""#fields"");
	fields_count = in.readUnsignedShort();
	if (fields_count != 0) {
		fields = new Field[fields_count];
		for (int i = 0; i < fields_count; i++) {
			prt(""#field :"" + i);
			fields[i] = readField(in);
		}
	}
}",True,"
*** SOURCE CODE: BEGIN ***
private void readFields() throws IOException {
	prt(""#fields"");
	fields_count = in.readUnsignedShort();
	if (fields_count != 0) {
		fields = new Field[fields_count];
		for (int i = 0; i < fields_count; i++) {
			prt(""#field :"" + i);
			fields[i] = readField(in);
		}
	}
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 3
LOC_method = 11
CYCLO_method = 3
NMCS_method = 0
NOLV_method = 1
MaMCL_method = 0
NOAV_method = 4
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 3
CLNAMM_method = 2
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,private void readInterfaces() throws IOException,0,0,0,0,0,3,10,3,0,1,0,4,1.0,0,0,3,1,0,0,0.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,3,3,0,3,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","private void readInterfaces() throws IOException {
	prt(""#interfaces"");
	interfaces_count = in.readUnsignedShort();
	if (interfaces_count != 0) {
		interfaces = new int[interfaces_count];
		for (int i = 0; i < interfaces_count; i++) {
			interfaces[i] = in.readUnsignedShort();
		}
	}
}",True,"
*** SOURCE CODE: BEGIN ***
private void readInterfaces() throws IOException {
	prt(""#interfaces"");
	interfaces_count = in.readUnsignedShort();
	if (interfaces_count != 0) {
		interfaces = new int[interfaces_count];
		for (int i = 0; i < interfaces_count; i++) {
			interfaces[i] = in.readUnsignedShort();
		}
	}
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 3
LOC_method = 10
CYCLO_method = 3
NMCS_method = 0
NOLV_method = 1
MaMCL_method = 0
NOAV_method = 4
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 3
CLNAMM_method = 1
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,private void readMethods() throws IOException,0,0,0,0,0,3,10,3,0,1,0,4,1.0,0,0,3,2,0,0,0.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,2,2,0,2,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","private void readMethods() throws IOException {
	prt(""#methods"");
	methods_count = in.readUnsignedShort();
	if (methods_count != 0) {
		methods = new Method[methods_count];
		for (int i = 0; i < methods_count; i++) {
			methods[i] = readMethod(in);
		}
	}
}",True,"
*** SOURCE CODE: BEGIN ***
private void readMethods() throws IOException {
	prt(""#methods"");
	methods_count = in.readUnsignedShort();
	if (methods_count != 0) {
		methods = new Method[methods_count];
		for (int i = 0; i < methods_count; i++) {
			methods[i] = readMethod(in);
		}
	}
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 3
LOC_method = 10
CYCLO_method = 3
NMCS_method = 0
NOLV_method = 1
MaMCL_method = 0
NOAV_method = 4
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 3
CLNAMM_method = 2
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,private void readSuper_class() throws IOException,0,0,0,0,0,1,3,1,0,0,0,2,1.0,0,0,2,0,0,0,0.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,1,-1,1,0,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","private void readSuper_class() throws IOException {
	super_class = in.readUnsignedShort();
}",False,"
*** SOURCE CODE: BEGIN ***
private void readSuper_class() throws IOException {
	super_class = in.readUnsignedShort();
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 1
LOC_method = 3
CYCLO_method = 1
NMCS_method = 0
NOLV_method = 0
MaMCL_method = 0
NOAV_method = 2
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,private void readThis_class() throws IOException,0,0,0,0,0,1,3,1,0,0,0,2,1.0,0,0,2,0,0,0,0.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,1,-1,1,0,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","private void readThis_class() throws IOException {
	this_class = in.readUnsignedShort();
}",False,"
*** SOURCE CODE: BEGIN ***
private void readThis_class() throws IOException {
	this_class = in.readUnsignedShort();
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 1
LOC_method = 3
CYCLO_method = 1
NMCS_method = 0
NOLV_method = 0
MaMCL_method = 0
NOAV_method = 2
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,private void readVersion() throws IOException,0,0,0,0,0,1,5,1,0,0,0,3,1.0,0,0,3,1,0,0,0.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,2,2,0,2,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","private void readVersion() throws IOException {
	prt(""#version"");
	minor_Version = in.readUnsignedShort();
	major_Version = in.readUnsignedShort();
}",True,"
*** SOURCE CODE: BEGIN ***
private void readVersion() throws IOException {
	prt(""#version"");
	minor_Version = in.readUnsignedShort();
	major_Version = in.readUnsignedShort();
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 0
ATFD_method = 0
FDP_method = 0
CM_method = 0
MAXNESTING_method = 1
LOC_method = 5
CYCLO_method = 1
NMCS_method = 0
NOLV_method = 0
MaMCL_method = 0
NOAV_method = 3
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 3
CLNAMM_method = 1
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.JavaClassParser,public JavaClass parseClass(File classFile) throws IOException,1,0,16,1,0,3,45,2,0,4,0,36,0.515151515,1,1,17,11,1,0,1.0,0,0,0,21,0,44,31,21,17,0,1,569,569,32,1,0,35,53,0,91,0.911764706,1.0,91,4.333333333,4.333333333,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,17,0,0,1,20,0,0,0,0,21,1,0,0,1,20,21,0,0,0,17,0,0,0,1,1,0,1,"/*
 * Author jyang Created on 2006-4-2 21:18:16
 */
package com.jasml.decompiler;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.OpcodeInfo;
import com.jasml.helper.Util;


public class JavaClassParser {

	DataInputStream in;

	int magic;

	int minor_Version;

	int major_Version;

	short constant_Pool_Count;

	ConstantPool constantPool;

	short access_flags;

	int this_class;

	int super_class;

	int interfaces_count;

	// the array storing interface indexes into constant pool
	int[] interfaces;

	int fields_count;

	Field[] fields;

	int methods_count;

	Method[] methods;

	int attributes_count;

	Attribute[] attributes;

	public JavaClass parseClass(File classFile) throws IOException {
		JavaClass ret = null;
		try {
			FileInputStream fsin = new FileInputStream(classFile);
			in = new DataInputStream(fsin);

			readMagic();
			readVersion();
			readConstant_Pool_Count();
			readConstantPool();
			// prt(constantPool); // 
			readAccess_flags();
			readThis_class();
			readSuper_class();
			readInterfaces();
			readFields();
			readMethods();
			readAttributes();

			ret = new JavaClass();
			ret.magic = magic;
			ret.minor_version = minor_Version;
			ret.major_version = major_Version;
			ret.constant_pool_count = constant_Pool_Count;
			ret.constantPool = constantPool;
			ret.access_flags = access_flags;
			ret.this_class = this_class;
			ret.super_class = super_class;
			ret.interfaces_count = interfaces_count;
			ret.interfaces = interfaces;
			ret.fields_count = fields_count;
			ret.fields = fields;
			ret.methods_count = methods_count;
			ret.methods = methods;
			ret.attributes_count = attributes_count;
			ret.attributes = attributes;
		} finally {
			try {
				in.close();
			} catch (Exception e) {

			}
		}
		return ret;
	}

	private void readMagic() throws IOException {
		prt(""#magic"");
		magic = in.readInt();
	}

	private void readVersion() throws IOException {
		prt(""#version"");
		minor_Version = in.readUnsignedShort();
		major_Version = in.readUnsignedShort();
	}

	private void readConstant_Pool_Count() throws IOException {
		prt(""#constant pool"");
		constant_Pool_Count = (short) in.readUnsignedShort();
	}

	private void readConstantPool() throws IOException {
		ConstantPoolItem[] items = new ConstantPoolItem[constant_Pool_Count];
		byte tag;
		for (int i = 1; i < constant_Pool_Count; i++) {
			tag = in.readByte();

			switch (tag) {
			case Constants.CONSTANT_Class:
				items[i] = new Constant_Class(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Fieldref:
				items[i] = new Constant_Fieldref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Methodref:
				items[i] = new Constant_Methodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_InterfaceMethodref:
				items[i] = new Constant_InterfaceMethodref(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_String:
				items[i] = new Constant_String(in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Integer:
				items[i] = new Constant_Integer(in.readInt());
				break;
			case Constants.CONSTANT_Float:
				items[i] = new Constant_Float(in.readFloat());
				break;
			case Constants.CONSTANT_Long:
				items[i] = new Constant_Long(in.readLong());
				i++;
				break;
			case Constants.CONSTANT_Double:
				items[i] = new Constant_Double(in.readDouble());
				i++;
				break;
			case Constants.CONSTANT_NameAndType:
				items[i] = new Constant_NameAndType(in.readUnsignedShort(), in.readUnsignedShort());
				break;
			case Constants.CONSTANT_Utf8:
				items[i] = new Constant_Utf8(in.readUTF());
				break;
			default:
				throw new IOException(""Error inputing class file, unexpected tag:"" + tag + "". i = "" + i);
			}
		}
		constantPool = new ConstantPool(items);
	}

	private void readAccess_flags() throws IOException {
		access_flags = (short) in.readUnsignedShort();	
	}

	private void readThis_class() throws IOException {
		this_class = in.readUnsignedShort();
	}

	private void readSuper_class() throws IOException {
		super_class = in.readUnsignedShort();
	}

	private void readInterfaces() throws IOException {
		prt(""#interfaces"");
		interfaces_count = in.readUnsignedShort();
		if (interfaces_count != 0) {
			interfaces = new int[interfaces_count];
			for (int i = 0; i < interfaces_count; i++) {
				interfaces[i] = in.readUnsignedShort();
			}
		}
	}

	private void readFields() throws IOException {
		prt(""#fields"");
		fields_count = in.readUnsignedShort();
		if (fields_count != 0) {
			fields = new Field[fields_count];
			for (int i = 0; i < fields_count; i++) {
				prt(""#field :"" + i);
				fields[i] = readField(in);
			}
		}
	}

	private void readMethods() throws IOException {
		prt(""#methods"");
		methods_count = in.readUnsignedShort();
		if (methods_count != 0) {
			methods = new Method[methods_count];
			for (int i = 0; i < methods_count; i++) {
				methods[i] = readMethod(in);
			}
		}
	}

	private void readAttributes() throws IOException {
		prt(""#class attributes"");
		attributes_count = in.readUnsignedShort();
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];
			for (int i = 0; i < attributes_count; i++) {
				prt(""#class attribute :"" + i);
				attributes[i] = readAttribute(in);
			}
		}
	}

	private Field readField(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Field(access_flags, name_index, descriptor_index, attributes_count, attributes);
	}

	private Method readMethod(DataInputStream in) throws IOException {
		int access_flags = in.readUnsignedShort();
		int name_index = in.readUnsignedShort();
		int descriptor_index = in.readUnsignedShort();
		int attributes_count = in.readUnsignedShort();
		prt(""#method :"" + constantPool.getConstant(name_index));
		Attribute[] attributes = null;
		if (attributes_count != 0) {
			attributes = new Attribute[attributes_count];

			for (int i = 0; i < attributes_count; i++) {
				attributes[i] = readAttribute(in);
			}
		}
		return new Method(access_flags, name_index, descriptor_index, attributes_count, attributes);

	}

	private Attribute readAttribute(DataInputStream in) throws IOException {
		prt(""#Attribute"");
		Attribute attribute = null;
		int attribute_name_index = in.readUnsignedShort();
		int attribute_length = in.readInt();
		String attribute_name = ((Constant_Utf8) constantPool.getConstant(attribute_name_index)).bytes;
		int i = 0;

		// get the attribute names
		for (; i < Constants.ATTRIBUTE_NAMES.length; i++) {
			if (attribute_name.equals(Constants.ATTRIBUTE_NAMES[i]) == true) {
				break;
			}
		}

		if (i != Constants.ATTRIBUTE_NAMES.length) {
			// known attribute
			switch (i) {
			case Constants.ATTRIBUTE_SourceFile:
				attribute = new Attribute_SourceFile(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_ConstantValue:
				attribute = new Attribute_ConstantValue(attribute_length, in.readUnsignedShort());
				break;
			case Constants.ATTRIBUTE_Code:
				int max_stack = in.readUnsignedShort();
				int max_locals = in.readUnsignedShort();
				int code_length = in.readInt();
				Attribute_Code.Opcode[] codes = null;
				if (code_length != 0) {
					byte[] bcode = new byte[code_length];
					in.read(bcode);
					codes = parseOpcodes(bcode);
				}
				int exception_table_length = in.readUnsignedShort();
				Attribute_Code.ExceptionTableItem[] exceptionTable = null;
				if (exception_table_length != 0) {
					exceptionTable = new Attribute_Code.ExceptionTableItem[exception_table_length];
					for (int counter = 0; counter < exception_table_length; counter++) {
						exceptionTable[counter] = readExceptionTableItem(in);
					}
				}

				int attributes_count = in.readUnsignedShort();
				Attribute[] attributes = null;
				if (attributes_count != 0) {
					attributes = new Attribute[attributes_count];
					for (int counter = 0; counter < attributes_count; counter++) {
						attributes[counter] = readAttribute(in);
					}
				}
				attribute = new Attribute_Code(attribute_length, max_stack, max_locals, code_length, codes, exception_table_length, exceptionTable,
						attributes_count, attributes);
				break;

			case Constants.ATTRIBUTE_Exceptions:
				int number_of_exceptions = in.readUnsignedShort();
				int[] exception_index_table = null;
				if (number_of_exceptions != 0) {
					exception_index_table = new int[number_of_exceptions];
					for (int counter = 0; counter < number_of_exceptions; counter++) {
						exception_index_table[counter] = in.readUnsignedShort();
					}
				}
				attribute = new Attribute_Exceptions(attribute_length, number_of_exceptions, exception_index_table);
				break;

			case Constants.ATTRIBUTE_InnerClasses:
				int number_of_classes = in.readUnsignedShort();
				Attribute_InnerClasses.InnerClass[] innerClasses = null;
				if (number_of_classes != 0) {
					innerClasses = new Attribute_InnerClasses.InnerClass[number_of_classes];
					for (int counter = 0; counter < number_of_classes; counter++) {
						innerClasses[counter] = readInnerClass(in);
					}
				}
				attribute = new Attribute_InnerClasses(attribute_length, number_of_classes, innerClasses);
				break;

			case Constants.ATTRIBUTE_Synthetic:
				attribute = new Attribute_Synthetic();
				break;

			case Constants.ATTRIBUTE_LineNumberTable:
				int line_number_table_length = in.readUnsignedShort();
				Attribute_LineNumberTable.LineNumber[] line_number_table = null;
				if (line_number_table_length != 0) {
					line_number_table = new Attribute_LineNumberTable.LineNumber[line_number_table_length];
					for (int counter = 0; counter < line_number_table_length; counter++) {
						line_number_table[counter] = readLineNumber(in);
					}
				}
				attribute = new Attribute_LineNumberTable(attribute_length, line_number_table_length, line_number_table);
				break;

			case Constants.ATTRIBUTE_LocalVariableTable:
				int local_variable_table_length = in.readUnsignedShort();
				Attribute_LocalVariableTable.LocalVariable[] local_variable_table = null;
				if (local_variable_table_length != 0) {
					local_variable_table = new Attribute_LocalVariableTable.LocalVariable[local_variable_table_length];
					for (int counter = 0; counter < local_variable_table_length; counter++) {
						local_variable_table[counter] = readLocalVariable(in);
					}
				}
				attribute = new Attribute_LocalVariableTable(attribute_length, local_variable_table_length, local_variable_table);
				break;
			case Constants.ATTRIBUTE_Deprecated:
				attribute = new Attribute_Deprecated();
				break;
			}
		} else {
			byte[] info = new byte[attribute_length];
			in.read(info);
			attribute = new Attribute(attribute_name_index, attribute_length, info);
		}
		return attribute;
	}

	private Attribute_Code.ExceptionTableItem readExceptionTableItem(DataInputStream in) throws IOException {
		return new Attribute_Code.ExceptionTableItem(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_InnerClasses.InnerClass readInnerClass(DataInputStream in) throws IOException {
		return new Attribute_InnerClasses.InnerClass(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LineNumberTable.LineNumber readLineNumber(DataInputStream in) throws IOException {
		return new Attribute_LineNumberTable.LineNumber(in.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_LocalVariableTable.LocalVariable readLocalVariable(DataInputStream in) throws IOException {
		return new Attribute_LocalVariableTable.LocalVariable(in.readUnsignedShort(), in.readUnsignedShort(), in.readUnsignedShort(), in
				.readUnsignedShort(), in.readUnsignedShort());
	}

	private Attribute_Code.Opcode[] parseOpcodes(byte[] bytes) {
		ArrayList ret = new ArrayList(bytes.length);
		Attribute_Code.Opcode op;
		OpcodeInfo opInfo;
		int offset;
		byte[][] operands = null;
		boolean wide = false;

		for (int i = 0; i < bytes.length; i++) {
			offset = i;
			opInfo = OpcodeHelper.OPCODES[0xFF & bytes[i]];
			if (opInfo.operandsLength == null) {
				operands = null;
			} else {
				if (opInfo.opcode == Constants.TABLESWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// low value
					byte[] lowb = new byte[4];
					for (int t = 0; t < 4; t++) {
						lowb[t] = bytes[i + t];
					}
					i = i + 4;

					// high byte
					byte[] highb = new byte[4];
					for (int t = 0; t < 4; t++) {
						highb[t] = bytes[i + t];
					}
					i = i + 4;

					int high = Util.getNum(highb);
					int low = Util.getNum(lowb);
					int total = high - low + 1 + 3 + 1; // number of jump offsets + one byte of opcode + high byte +low byte+defualt byte+padding byte
					if (total < 0) {
						total = 1;
					}
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = lowb;
					operands[3] = highb;

					for (int t = 4; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.LOOKUPSWITCH) {
					int padnum = i % 4;
					padnum = 3 - padnum;
					i = i + padnum + 1;

					// defualt value
					byte[] defaultb = new byte[4];
					for (int t = 0; t < 4; t++) {
						defaultb[t] = bytes[i + t];
					}
					i = i + 4;

					// npair value
					byte[] npairb = new byte[4];
					for (int t = 0; t < 4; t++) {
						npairb[t] = bytes[i + t];
					}
					i = i + 4;

					int npair = Util.getNum(npairb);

					int total = npair * 2 + 3; // npair *2 +defualt byte+one byte of opcode+padding bytes
					operands = new byte[total][4];
					operands[0] = new byte[padnum];
					for (int ti = 0; ti < padnum; ti++) {
						operands[0][ti] = (byte) 0;
					}
					operands[1] = defaultb;
					operands[2] = npairb;
					for (int t = 3; t < total; t++) {
						operands[t][0] = bytes[i++];
						operands[t][1] = bytes[i++];
						operands[t][2] = bytes[i++];
						operands[t][3] = bytes[i++];
					}
					i--;
				} else if (opInfo.opcode == Constants.WIDE) {
					wide = true;
				} else if (wide == true) {
					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j] + 1; t++) {
							operands[j][t] = bytes[++i];
						}
					}
					wide = false;
				} else {

					operands = new byte[opInfo.operandsLength.length][];
					for (int j = 0; j < opInfo.operandsLength.length; j++) {
						operands[j] = new byte[opInfo.operandsLength[j]];
						for (int t = 0; t < opInfo.operandsLength[j]; t++) {
							operands[j][t] = bytes[++i];
						}
					}
				}
			}
			op = new Attribute_Code.Opcode(offset, opInfo.opcode, operands);
			ret.add(op);
		}
		return (Attribute_Code.Opcode[]) ret.toArray(new Attribute_Code.Opcode[0]);
	}

	private static void prt(Object s) {
		//				 System.out.println(s);
	} //	class DataInputStream {
	//		java.io.DataInputStream in;
	//
	//		public DataInputStream(FileInputStream ins) {
	//			in = new java.io.DataInputStream(ins);
	//		}
	//
	//		public int readInt() throws IOException {
	//			int i = in.readInt();
	//			prt(""int:"" + i);
	//			return i;
	//		}
	//
	//		public int readUnsignedShort() throws IOException {
	//			int i = in.readUnsignedShort();
	//			prt(""sho:"" + i);
	//			return i;
	//		}
	//
	//		public byte readByte() throws IOException {
	//			byte b = in.readByte();
	//			prt(""bye:"" + b);
	//			return b;
	//		}
	//
	//		public int read(byte[] b) throws IOException {
	//			int i = in.read(b);
	//			StringBuffer buf = new StringBuffer();
	//			for (int t = 0; t < i; t++) {
	//				buf.append(Integer.toString(b[t] & 0xFF) + "","");
	//			}
	//			prt(buf.toString());
	//			return i;
	//		}
	//
	//		public float readFloat() throws IOException {
	//			float f = in.readFloat();
	//			prt(""flo:"" + f);
	//			return f;
	//
	//		}
	//
	//		public long readLong() throws IOException {
	//			long l = in.readLong();
	//			prt(""long:"" + l);
	//			return l;
	//		}
	//
	//		public double readDouble() throws IOException {
	//			double d = in.readDouble();
	//			prt(""dou:"" + d);
	//			return d;
	//		}
	//
	//		public String readUTF() throws IOException {
	//			String d = in.readUTF();
	//			prt(""str:"" + d);
	//			return d;
	//		}
	//
	//		public void close() throws IOException {
	//			in.close();
	//		}
	//
	//	}
}","public JavaClass parseClass(File classFile) throws IOException {
	JavaClass ret = null;
	try {
		FileInputStream fsin = new FileInputStream(classFile);
		in = new DataInputStream(fsin);

		readMagic();
		readVersion();
		readConstant_Pool_Count();
		readConstantPool();
		// prt(constantPool); // 
		readAccess_flags();
		readThis_class();
		readSuper_class();
		readInterfaces();
	 readFields();
 	 readMethods();
 	 readAttributes();

 	 ret = new JavaClass();
 	 ret.magic = magic;
 	 ret.minor_version = minor_Version;
 	 ret.major_version = major_Version;
 	 ret.constant_pool_count = constant_Pool_Count;
 	 ret.constantPool = constantPool;
 	 ret.access_flags = access_flags;
 	 ret.this_class = this_class;
 	 ret.super_class = super_class;
 	 ret.interfaces_count = interfaces_count;
 	 ret.interfaces = interfaces;
 	 ret.fields_count = fields_count;
 	 ret.fields = fields;
 	 ret.methods_count = methods_count;
 	 ret.methods = methods;
 	 ret.attributes_count = attributes_count;
 	 ret.attributes = attributes;
  } finally {
   try {
in.close();
b} catch (Exception e) {
b}
c}
dreturnret;}",True,"
*** SOURCE CODE: BEGIN ***
public JavaClass parseClass(File classFile) throws IOException {
	JavaClass ret = null;
	try {
		FileInputStream fsin = new FileInputStream(classFile);
		in = new DataInputStream(fsin);

		readMagic();
		readVersion();
		readConstant_Pool_Count();
		readConstantPool();
		// prt(constantPool); // 
		readAccess_flags();
		readThis_class();
		readSuper_class();
		readInterfaces();
	 readFields();
 	 readMethods();
 	 readAttributes();

 	 ret = new JavaClass();
 	 ret.magic = magic;
 	 ret.minor_version = minor_Version;
 	 ret.major_version = major_Version;
 	 ret.constant_pool_count = constant_Pool_Count;
 	 ret.constantPool = constantPool;
 	 ret.access_flags = access_flags;
 	 ret.this_class = this_class;
 	 ret.super_class = super_class;
 	 ret.interfaces_count = interfaces_count;
 	 ret.interfaces = interfaces;
 	 ret.fields_count = fields_count;
 	 ret.fields = fields;
 	 ret.methods_count = methods_count;
 	 ret.methods = methods;
 	 ret.attributes_count = attributes_count;
 	 ret.attributes = attributes;
  } finally {
   try {
in.close();
b} catch (Exception e) {
b}
c}
dreturnret;}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 0
ATFD_method = 16
FDP_method = 1
CM_method = 0
MAXNESTING_method = 3
LOC_method = 45
CYCLO_method = 2
NMCS_method = 0
NOLV_method = 4
MaMCL_method = 0
NOAV_method = 36
LAA_method = 0.515151515
FANOUT_method = 1
CFNAMM_method = 1
ATLD_method = 17
CLNAMM_method = 11
CINT_method = 1
MeMCL_method = 0
CDISP_method = 1.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 21
NMO_type = 0
ATFD_type = 44
FANOUT_type = 31
NOMNAMM_type = 21
NOA_type = 17
NIM_type = 0
DIT_type = 1
LOC_type = 569
LOCNAMM_type = 569
CFNAMM_type = 32
TCC_type = 1
NOPA_type = 0
CBO_type = 35
RFC_type = 53
NOC_type = 0
WMC_type = 91
LCOM5_type = 0.911764706
WOC_type = 1.0
WMCNAMM_type = 91
AMW_type = 4.333333333
AMWNAMM_type = 4.333333333
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 17
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 1
number_private_visibility_methods = 20
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 21
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 20
number_standard_design_methods = 21
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 0
num_final_static_attributes = 0
num_not_final_not_static_attributes = 17
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.decompiler.SourceCodeBuilder,private String toString(Attribute_LineNumberTable attr),1,0,7,4,0,2,12,3,0,3,0,11,0.125,0,0,1,0,0,0,0.0,0,0,0,31,0,173,4,31,2,0,1,828,828,13,1,0,36,44,0,213,0.666666667,1.0,213,6.870967742,6.870967742,3,54,0,1422,54,4,48,1,245,233,6694,0,0,0,2,0,0,4,27,0,0,0,0,31,1,0,0,1,30,29,0,2,0,2,0,0,0,78,24,27,51,"/*
 * Author jyang Created on 2006-4-5 10:30:53
 */
package com.jasml.decompiler;

import java.util.HashSet;

import com.jasml.classes.Attribute;
import com.jasml.classes.Attribute_Code;
import com.jasml.classes.Attribute_ConstantValue;
import com.jasml.classes.Attribute_Deprecated;
import com.jasml.classes.Attribute_Exceptions;
import com.jasml.classes.Attribute_InnerClasses;
import com.jasml.classes.Attribute_LineNumberTable;
import com.jasml.classes.Attribute_LocalVariableTable;
import com.jasml.classes.Attribute_SourceFile;
import com.jasml.classes.Attribute_Synthetic;
import com.jasml.classes.ConstantPool;
import com.jasml.classes.ConstantPoolItem;
import com.jasml.classes.Constant_Class;
import com.jasml.classes.Constant_Double;
import com.jasml.classes.Constant_Fieldref;
import com.jasml.classes.Constant_Float;
import com.jasml.classes.Constant_Integer;
import com.jasml.classes.Constant_InterfaceMethodref;
import com.jasml.classes.Constant_Long;
import com.jasml.classes.Constant_Methodref;
import com.jasml.classes.Constant_NameAndType;
import com.jasml.classes.Constant_String;
import com.jasml.classes.Constant_Utf8;
import com.jasml.classes.Constants;
import com.jasml.classes.Field;
import com.jasml.classes.JavaClass;
import com.jasml.classes.Method;
import com.jasml.classes.Attribute_LocalVariableTable.LocalVariable;
import com.jasml.helper.OpcodeHelper;
import com.jasml.helper.Util;

public class SourceCodeBuilder {
	ConstantPool cpl;

	SourceCodeBuilderConfiguration config;

	public SourceCodeBuilder() {
		config = new SourceCodeBuilderConfiguration();
	}

	public SourceCodeBuilder(SourceCodeBuilderConfiguration config) {
		this.config = config;
	}

	private String toString(Attribute_ConstantValue var) {
		return toString(cpl.getConstant(var.constant_value_index));
	}

	private String toString(Attribute_Deprecated var) {
		return ""["" + Constants.ATTRIBUTE_NAME_DEPRECATED + ""]"";
	}

	private String toString(Attribute_Synthetic var) {
		return ""["" + Constants.ATTRIBUTE_NAME_SYNTHETIC + ""]"";
	}

	private String toString(Attribute_SourceFile var) {
		return ""["" + Constants.ATTRIBUTE_NAME_SOURCE_FILE + "" : "" + toString(cpl.getConstant(var.sourcefile_index)) + ""]"";
	}

	private String toString(Attribute_LocalVariableTable attr, Attribute_Code.Opcode[] ops) {
		if (attr.local_variable_table_length == 0)
			return """";
		StringBuffer buf = new StringBuffer();
		buf.append(""["" + Constants.ATTRIBUTE_NAME_LOCAL_VARIABLE + "" :"");
		LocalVariable var;
		for (int i = 0; i < attr.local_variable_table_length; i++) {
			var = attr.local_variable_table[i];
			buf.append(Constants.LINE_SEPARATER);
			buf.append(Util.descriptorToString(toString(cpl.getConstant(var.descriptor_index)))); // descriptor
			buf.append("" "");
			buf.append(toString(cpl.getConstant(var.name_index))); // name
			buf.append(""  "");
			buf.append(""start="" + config.labelPrefix + var.start_pc); // start position
			buf.append("", "");
			buf.append(""end="" + config.labelPrefix + (findPreviousInstruction(var.start_pc + var.length, ops)).offset); // valid scope
			buf.append("", "");
			buf.append(""index="" + var.index); // index into runtime frame
		}
		buf.append(""]"");
		return buf.toString();
	}

	private String toString(Attribute_LineNumberTable attr) {
		if (attr.line_number_table_length == 0)
			return """";
		StringBuffer buf = new StringBuffer();
		buf.append(""["" + Constants.ATTRIBUTE_NAME_LINE_NUMBER_TABLE + "" :"");
		for (int i = 0; i < attr.line_number_table_length; i++) {
			buf.append(Constants.LINE_SEPARATER);
			buf.append(config.labelPrefix + attr.lineNumberTable[i].start_pc + "" ->  "" + attr.lineNumberTable[i].line_number);
		}
		buf.append(""]"");
		return buf.toString();
	}

	private String toString(Attribute_InnerClasses attr) {
		StringBuffer buf = new StringBuffer();
		Attribute_InnerClasses.InnerClass innerClass;
		buf.append(""["" + Constants.ATTRIBUTE_NAME_INNER_CLASSES + "" :"");
		for (int i = 0; i < attr.number_of_classes; i++) {
			buf.append(Constants.LINE_SEPARATER);
			innerClass = attr.innerClasses[i];
			// access flag
			buf.append(""access = "" + Util.accessFlagToString_Class((short) innerClass.inner_class_access_flags) + "" , "");
			// inner class name
			buf.append(""name = "");
			if (innerClass.inner_name_index == 0) {
				buf.append(""0 , "");
			} else {
				buf.append(toString(cpl.getConstant(innerClass.inner_name_index)) + "" , "");
			}

			// inner class info
			buf.append(""fullname = "");
			buf.append(toString(cpl.getConstant(innerClass.inner_class_info_index)) + "" , "");

			// outer class info
			buf.append(""outername = "");
			if (innerClass.outer_class_info_index == 0) {
				buf.append(""0"");
			} else {
				buf.append(toString(cpl.getConstant(innerClass.outer_class_info_index)));
			}
		}
		buf.append(']');
		return buf.toString();
	}

	private String toString(Attribute_Exceptions attr) {
		if (attr.number_of_exceptions == 0)
			return """";

		StringBuffer buf = new StringBuffer();
		for (int i = 0; i < attr.number_of_exceptions; i++) {
			buf.append(toString(cpl.getConstant(attr.exception_index_table[i])) + "","");
		}
		buf.deleteCharAt(buf.length() - 1);
		return buf.toString();
	}

	private String getLocalVariableName(int index, int codeOffset, Attribute_LocalVariableTable.LocalVariable[] lvts) {
		if (lvts == null) {
			return ""UnknowVariable"";
		}
		int i;
		Attribute_LocalVariableTable.LocalVariable lv;
		for (i = 0; i < lvts.length; i++) {
			lv = lvts[i];
			if (lv.index == index && lv.start_pc <= codeOffset && (lv.start_pc + lv.length) >= codeOffset) {
				return toString(cpl.getConstant(lv.name_index));
			}
		}
		// no match found, TODO: why could this happen
		// search for the one with the same index value
		for (i = 0; i < lvts.length; i++) {
			lv = lvts[i];
			if (lv.index == index) {
				return toString(cpl.getConstant(lv.name_index));
			}
		}

		// still not found
		return ""unknown_local_variable"";

		// TODO: this is little tricky
	}

	private String toString(Attribute_Code code, HashSet referedLines) {
		StringBuffer buf = new StringBuffer();
		Attribute_Code.Opcode op;
		Attribute_Code.Opcode[] ops = code.codes;
		byte[][] operands;
		int ti, def, low, high, jump_count, npairs;
		String soffset;

		Attribute_LocalVariableTable.LocalVariable[] lvts = null;
		for (int i = 0; i < code.attributes_count; i++) {
			if (code.attributes[i] instanceof Attribute_LocalVariableTable) {
				lvts = ((Attribute_LocalVariableTable) code.attributes[i]).local_variable_table;
				break;
			}
		}

		// instructions
		if (code.code_length != 0) {
			for (int t = 0; t < ops.length; t++) {
				op = ops[t];
				operands = op.operands;
				// offset
				soffset = Integer.toString(op.offset);
				if (referedLines.contains(soffset) == true) {
					if (config.labelInSingleLine == true) {
						buf.append(config.labelPrefix + soffset + "" : "");
						buf.append(Constants.LINE_SEPARATER);
						buf.append(config.instructionPadding);
					} else {
						buf.append(Util.padChar(config.labelPrefix + soffset, config.labelLength, ' ') + "" : "");
					}
				} else {
					buf.append(config.instructionPadding);
				}
				// opcode name
				buf.append(Constants.OPCODE_NAMES[0xFF & op.opcode] + ""  "");
				switch (op.opcode) {
				case Constants.TABLESWITCH:
					def = Util.getNum(operands[1]) + op.offset;
					low = Util.getNum(operands[2]);
					high = Util.getNum(operands[3]);
					jump_count = high - low + 1;

					buf.append(""default="" + config.labelPrefix + def + "", low="" + low + "", high="" + high + "", jump_table:"");

					for (int i = 0; i < jump_count; i++) {
						// jump address is calculated by adding with tableswitch offset.
						buf.append(config.labelPrefix + (Util.getNum(operands[i + 4]) + op.offset) + "","");
					}
					buf.deleteCharAt(buf.length() - 1);
					break;
				case Constants.LOOKUPSWITCH: {
					def = Util.getNum(operands[1]) + op.offset;
					npairs = Util.getNum(operands[2]);

					buf.append(""default="" + config.labelPrefix + def + "", npairs="" + npairs + "", jump_table:"");
					if (npairs != 0) {
						for (int i = 0; i < npairs; i++) {
							buf.append(Util.getNum(operands[i * 2 + 3]));
							buf.append(""->"");
							buf.append(config.labelPrefix + (Util.getNum(operands[i * 2 + 4]) + op.offset) + "","");

						}
						buf.deleteCharAt(buf.length() - 1);
					}
				}
					break;
				/*
				 * Two address bytes + offset from start of byte stream form the
				 * jump target
				 */
				case Constants.GOTO:
				case Constants.IFEQ:
				case Constants.IFGE:
				case Constants.IFGT:
				case Constants.IFLE:
				case Constants.IFLT:
				case Constants.JSR:
				case Constants.IFNE:
				case Constants.IFNONNULL:
				case Constants.IFNULL:
				case Constants.IF_ACMPEQ:
				case Constants.IF_ACMPNE:
				case Constants.IF_ICMPEQ:
				case Constants.IF_ICMPGE:
				case Constants.IF_ICMPGT:
				case Constants.IF_ICMPLE:
				case Constants.IF_ICMPLT:
				case Constants.IF_ICMPNE:
				/*
				 * 32-bit wide jumps
				 */
				case Constants.GOTO_W:
				case Constants.JSR_W:
					buf.append(config.labelPrefix + (Util.getSignedNum(operands[0]) + op.offset));
					break;
				/*
				 * Index byte references local variable
				 */
				case Constants.ALOAD:
				case Constants.ASTORE:
				case Constants.DLOAD:
				case Constants.DSTORE:
				case Constants.FLOAD:
				case Constants.FSTORE:
				case Constants.ILOAD:
				case Constants.ISTORE:
				case Constants.LLOAD:
				case Constants.LSTORE:
				case Constants.RET:
					ti = Util.getNum(operands[0]); // the index into local variable
					// table
					buf.append(getLocalVariableName(ti, op.offset, lvts) + ""("" + ti + "")"");
					break;
				/*
				 * Remember wide byte which is used to form a 16-bit address in the
				 * following instruction. Relies on that the method is called again
				 * with the following opcode.
				 */
				case Constants.WIDE:
					// TODO: testing
					break;
				/*
				 * Array of basic type.
				 */
				case Constants.NEWARRAY:
					buf.append(Constants.TYPE_NAMES[Util.getNum(operands[0])]);
					break;
				/*
				 * Access object/class fields.
				 */
				case Constants.GETFIELD:
				case Constants.GETSTATIC:
				case Constants.PUTFIELD:
				case Constants.PUTSTATIC:
				/*
				 * Operands are references to classes in constant pool
				 */
				case Constants.NEW:
				case Constants.CHECKCAST:
				case Constants.INSTANCEOF:
				/*
				 * Operands are references to methods in constant pool
				 */
				case Constants.INVOKESPECIAL:
				case Constants.INVOKESTATIC:
				case Constants.INVOKEVIRTUAL:
					buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
					break;

				case Constants.INVOKEINTERFACE:
					buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
					buf.append("" "");
					buf.append(Util.getNum(operands[1]));
					break;

				/*
				 * Operands are references to items in constant pool
				 */
				case Constants.LDC_W:
				case Constants.LDC2_W:
				case Constants.LDC:
					buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
					break;

				/*
				 * Array of references.
				 */
				case Constants.ANEWARRAY:
					buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
					break;
				/*
				 * Multidimensional array of references.
				 */
				case Constants.MULTIANEWARRAY:
					buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
					buf.append(' ');					
					buf.append(Util.getNum(operands[1]));
					break;
				/*
				 * Increment local variable.
				 */
				case Constants.IINC:
					ti = Util.getNum(operands[0]);
					buf.append(getLocalVariableName(ti, op.offset, lvts) + ""("" + ti + "") "" + Util.getSignedNum(operands[1]));
					break;
				default:
					if (operands != null) {
						for (int i = 0; i < operands.length; i++) {
							buf.append(Util.getNum(operands[i]) + "" "");
						}
					}
				}

				if (config.showInfo == true) {
					buf.append(""   //"");
					buf.append(OpcodeHelper.getOpcodeInfo(op.opcode).operation);
				}
				buf.append(Constants.LINE_SEPARATER);
			}
		}

		// Local variable table
		for (int i = 0; i < code.attributes_count; i++) {
			if (code.attributes[i] instanceof Attribute_LocalVariableTable
					&& ((Attribute_LocalVariableTable) code.attributes[i]).local_variable_table_length != 0) {
				buf.append(Constants.LINE_SEPARATER);
				buf.append(toString((Attribute_LocalVariableTable) code.attributes[i], ops));
				break;
			}
		}

		// Exception table
		if (code.exception_table_length != 0) {
			buf.append(Constants.LINE_SEPARATER);
			buf.append(Constants.LINE_SEPARATER);

			buf.append(""["" + Constants.ATTRIBUTE_NAME_EXCEPTION_TABLE + "":"");
			for (int i = 0; i < code.exception_table_length; i++) {
				buf.append(Constants.LINE_SEPARATER);
				buf.append(""start="" + config.labelPrefix + code.exception_table[i].start_pc);
				buf.append("" , "");
				buf.append(""end="" + config.labelPrefix + code.exception_table[i].end_pc);
				buf.append("" , "");
				buf.append(""handler="" + config.labelPrefix + code.exception_table[i].handler_pc);
				buf.append("" , "");
				if (code.exception_table[i].catch_type != 0) {
					buf.append(""catch_type="" + toString(cpl.getConstant(code.exception_table[i].catch_type)));
				} else {
					buf.append(""catch_type=0"");
				}
			}
			buf.append(""]"");
		}

		// Line number table
		if (config.showLineNumber == true) {
			for (int i = 0; i < code.attributes_count; i++) {
				if (code.attributes[i] instanceof Attribute_LineNumberTable
						&& ((Attribute_LineNumberTable) code.attributes[i]).line_number_table_length != 0) {
					buf.append(Constants.LINE_SEPARATER);
					buf.append(Constants.LINE_SEPARATER);
					buf.append(toString((Attribute_LineNumberTable) code.attributes[i]));
					break;
				}
			}
		}

		// max_stack
		buf.append(Constants.LINE_SEPARATER);
		buf.append(Constants.LINE_SEPARATER);
		buf.append(""["" + Constants.ATTRIBUTE_NAME_MAX_STACK + "" : "" + code.max_stack + ""]"");
		// max_local
		buf.append(Constants.LINE_SEPARATER);
		buf.append(""["" + Constants.ATTRIBUTE_NAME_MAX_LOCAL + "" : "" + code.max_locals + ""]"");
		return buf.toString();
	}

	private String toString(Attribute var) {
		switch (var.attribute_tag) {
		case Constants.ATTRIBUTE_SourceFile:
			return toString((Attribute_SourceFile) var);

		case Constants.ATTRIBUTE_ConstantValue:
			return toString((Attribute_ConstantValue) var);

		case Constants.ATTRIBUTE_Code:
			return toString((Attribute_Code) var);

		case Constants.ATTRIBUTE_Exceptions:
			return toString((Attribute_Exceptions) var);

		case Constants.ATTRIBUTE_InnerClasses:
			return toString((Attribute_InnerClasses) var);

		case Constants.ATTRIBUTE_Synthetic:
			return toString((Attribute_Synthetic) var);

		case Constants.ATTRIBUTE_LineNumberTable:
			return toString((Attribute_LineNumberTable) var);

		case Constants.ATTRIBUTE_LocalVariableTable:
			return toString((Attribute_LocalVariableTable) var);

		case Constants.ATTRIBUTE_Deprecated:
			return toString((Attribute_Deprecated) var);

		default: {
			StringBuffer buf = new StringBuffer();
			if (var.attribute_name == null) {
				// this is an unknow attribute
				buf.append(toString(cpl.getConstant(var.attribute_name_index)));
			} else {
				buf.append(var.attribute_name);
			}
			if (var.attrInfo != null) {
				buf.append("" = "" + new String(var.attrInfo));
			}
			return buf.toString();
		}
		}

	}

	private String toString(Constant_Float var) {
		return Float.toString(var.value) + ""F"";
	}

	private String toString(Constant_Long var) {
		return Long.toString(var.value) + ""L"";
	}

	private String toString(Constant_Double var) {
		return Double.toString(var.value) + ""D"";
	}

	private String toString(Constant_Utf8 var) {
		return var.bytes;
	}

	private String toString(ConstantPoolItem var) {
		switch (var.tag) {
		case Constants.CONSTANT_Utf8:
			return toString((Constant_Utf8) var);
		case Constants.CONSTANT_Integer:
			return toString((Constant_Integer) var);

		case Constants.CONSTANT_Float:
			return toString((Constant_Float) var);

		case Constants.CONSTANT_Long:
			return toString((Constant_Long) var);

		case Constants.CONSTANT_Double:
			return toString((Constant_Double) var);

		case Constants.CONSTANT_Class:
			return toString((Constant_Class) var);

		case Constants.CONSTANT_Fieldref:
			return toString((Constant_Fieldref) var);

		case Constants.CONSTANT_String:
			return toString((Constant_String) var);

		case Constants.CONSTANT_Methodref:
			return toString((Constant_Methodref) var);

		case Constants.CONSTANT_InterfaceMethodref:
			return toString((Constant_InterfaceMethodref) var);

		case Constants.CONSTANT_NameAndType:
			return toString((Constant_NameAndType) var);
		default:
			return var.tagName;
		}
	}

	private String toString(Constant_Integer var) {
		return Integer.toString(var.value);
	}

	private String toString(Constant_Class var) {
		return Util.constantClassToString(toString((Constant_Utf8) cpl.getConstant(var.name_index)));
	}

	private String toString(Constant_Fieldref var) {
		String name, type, temp = toString(cpl.getConstant(var.name_and_type_index));
		int i = temp.indexOf("" "");
		name = temp.substring(0, i);
		type = temp.substring(i + 1);
		type = Util.descriptorToString(type);

		return type + "" "" + toString(cpl.getConstant(var.class_index)) + ""."" + name;
	}

	private String toString(Constant_InterfaceMethodref var) {
		String name, retType, para, temp = toString(cpl.getConstant(var.name_and_type_index));
		int i = temp.indexOf("" "");
		name = temp.substring(0, i);
		i = temp.indexOf((char) ')');
		para = temp.substring(temp.indexOf((char) '(') + 1, i);
		retType = temp.substring(i + 1, temp.length());

		para = Util.methodParameterToString(para);
		retType = Util.descriptorToString(retType);
		return retType + "" "" + toString(cpl.getConstant(var.class_index)) + ""."" + name + ""("" + para + "")"";
	}

	private String toString(Constant_Methodref var) {
		String name, retType, para = null, temp = toString(cpl.getConstant(var.name_and_type_index));
		int i = temp.indexOf("" "");
		name = temp.substring(0, i);
		i = temp.indexOf((char) ')');
		para = temp.substring(temp.indexOf((char) '(') + 1, i);
		retType = temp.substring(i + 1, temp.length());

		para = Util.methodParameterToString(para);
		retType = Util.descriptorToString(retType);
		return retType + "" "" + toString(cpl.getConstant(var.class_index)) + ""."" + name + ""("" + para + "")"";
	}

	private String toString(Constant_NameAndType var) {
		return toString(cpl.getConstant(var.name_index)) + "" "" + toString(cpl.getConstant(var.descriptor_index));
	}

	private String toString(Constant_String var) {
		return Util.toViewableString(toString(cpl.getConstant(var.string_index)));
	}

	public String toString(JavaClass clazz) {
		StringBuffer buf = new StringBuffer();
		this.cpl = clazz.constantPool;

		if (config.showVersion == true) {
			// Minor and Major version of the class
			buf.append(""[Major : "" + Integer.toString(clazz.major_version) + ""]"");
			buf.append(Constants.LINE_SEPARATER);
			buf.append(""[Minor : "" + Integer.toString(clazz.minor_version) + ""]"");
			buf.append(Constants.LINE_SEPARATER);
		}

		// class access flag + class name
		buf.append(Util.accessFlagToString_Class(clazz.access_flags) + "" "" + toString(cpl.getConstant(clazz.this_class)));
		// super classes
		if (clazz.super_class != 0) {
			// java.lang.Object dose not hava super class
			buf.append("" extends "" + toString(cpl.getConstant(clazz.super_class)));
		}
		// implemented interfaces
		if (clazz.interfaces_count != 0) {
			buf.append("" implements "");
			for (int i = 0; i < clazz.interfaces_count; i++) {
				buf.append(toString(cpl.getConstant(clazz.interfaces[i])) + "","");
			}
			buf.deleteCharAt(buf.length() - 1);
		}

		buf.append(""{"");

		// fields
		if (clazz.fields_count != 0) {
			for (int i = 0; i < clazz.fields_count; i++) {
				buf.append(Constants.LINE_SEPARATER);
				buf.append(toString(clazz.fields[i]));
			}
		}

		// methods
		if (clazz.methods_count != 0) {
			for (int i = 0; i < clazz.methods_count; i++) {
				buf.append(Constants.LINE_SEPARATER);
				buf.append(toString(clazz.methods[i]));
			}
		}

		// attributes of this class
		if (clazz.attributes_count != 0) {
			buf.append(Constants.LINE_SEPARATER);
			for (int i = 0; i < clazz.attributes_count; i++) {
				buf.append(Constants.LINE_SEPARATER);
				String tx = toString(clazz.attributes[i]);
				buf.append(tx);
			}
		}

		buf.append(Constants.LINE_SEPARATER);
		buf.append(""}"");
		return buf.toString();
	}

	private String toString(Field field) {
		StringBuffer buf = new StringBuffer();

		// access flag
		buf.append(Util.accessFlagToString_Field((short) field.access_flags) + "" "");
		// field descriptor
		buf.append(Util.descriptorToString(toString(cpl.getConstant(field.descriptor_index))) + "" "");
		// field name
		buf.append(toString(cpl.getConstant(field.name_index)));
		// constant value
		if (field.attributes_count != 0) {
			for (int i = 0; i < field.attributes_count; i++) {
				if (field.attributes[i] instanceof Attribute_ConstantValue) {
					buf.append("" = "");
					buf.append(toString(field.attributes[i]));
				}
			}
		}

		// deprecated or synthetic attribute
		if (field.attributes_count != 0) {
			for (int i = 0; i < field.attributes_count; i++) {
				if ((field.attributes[i] instanceof Attribute_ConstantValue) == false) {
					buf.append('\t');
					buf.append(toString(field.attributes[i]));
				}
			}
		}
		return buf.toString().trim();
	}

	private String toString(Method method) {
		StringBuffer buf = new StringBuffer();

		// method access flag
		buf.append(Util.accessFlagToString_Method((short) method.access_flags) + "" "");

		// method parameter and return type
		String retType, paras, temp = toString(cpl.getConstant(method.descriptor_index));
		int ti = temp.indexOf("")"");
		paras = Util.methodParameterToString(temp.substring(1, ti));
		retType = Util.descriptorToString(temp.substring(ti + 1));

		// return type
		buf.append(retType + "" "");
		// method name
		buf.append(toString(cpl.getConstant(method.name_index)) + "" "");
		// method para
		buf.append(""("" + paras + "")"");

		// exception
		if (method.attributes_count != 0) {
			for (int i = 0; i < method.attributes_count; i++) {
				if (method.attributes[i].attribute_tag == Constants.ATTRIBUTE_Exceptions) {
					buf.append("" throws "");
					buf.append(toString(method.attributes[i]));
				}
			}
		}

		buf.append(""{"");
		// code
		if (method.attributes_count != 0) {
			for (int i = 0; i < method.attributes_count; i++) {
				if (method.attributes[i].attribute_tag == Constants.ATTRIBUTE_Code) {
					buf.append(Constants.LINE_SEPARATER);
					buf.append(toString((Attribute_Code) method.attributes[i], calculateReferences(method)));
				}
			}
		}
		if (method.attributes_count != 0) {
			for (int i = 0; i < method.attributes_count; i++) {
				if (method.attributes[i].attribute_tag != Constants.ATTRIBUTE_Code
						&& method.attributes[i].attribute_tag != Constants.ATTRIBUTE_Exceptions) {
					buf.append(Constants.LINE_SEPARATER);
					buf.append(toString(method.attributes[i]));
				}
			}

		}
		buf.append(Constants.LINE_SEPARATER);
		buf.append(""}"");

		return buf.toString();
	}

	/**
	 * generate a set containing all the line numbers which are refered inside
	 * the method.
	 * 
	 * @param meth
	 * @return
	 */
	private HashSet calculateReferences(Method meth) {
		HashSet set = new HashSet();
		Attribute att;
		Attribute_Code.Opcode[] ops = null;
		Attribute_Code.Opcode op;
		for (int i = 0; i < meth.attributes_count; i++) {
			if (meth.attributes[i].attribute_tag == Constants.ATTRIBUTE_Code) {
				ops = ((Attribute_Code) meth.attributes[i]).codes;
				break;
			}
		}
		if (ops == null) {
			return set;
		}

		for (int i = 0; i < meth.attributes_count; i++) {
			att = meth.attributes[i];
			if (att.attribute_tag == Constants.ATTRIBUTE_Code) {
				Attribute_Code code = (Attribute_Code) att;
				for (int j = 0; j < ops.length; j++) {
					op = ops[j];
					switch (op.opcode) {

					case Constants.LOOKUPSWITCH:
						set.add(Integer.toString(Util.getSignedNum(op.operands[1]) + op.offset)); //default
						for (int t = 4; t < op.operands.length; t++) {
							set.add(Integer.toString(Util.getSignedNum(op.operands[t++]) + op.offset));
						}
						break;
					case Constants.TABLESWITCH:
						set.add(Integer.toString(Util.getSignedNum(op.operands[1]) + op.offset)); //default
						for (int t = 4; t < op.operands.length; t++) {
							set.add(Integer.toString(Util.getSignedNum(op.operands[t]) + op.offset));
						}
						break;
					case Constants.GOTO:
					case Constants.IFEQ:
					case Constants.IFGE:
					case Constants.IFGT:
					case Constants.IFLE:
					case Constants.IFLT:
					case Constants.JSR:
					case Constants.IFNE:
					case Constants.IFNONNULL:
					case Constants.IFNULL:
					case Constants.IF_ACMPEQ:
					case Constants.IF_ACMPNE:
					case Constants.IF_ICMPEQ:
					case Constants.IF_ICMPGE:
					case Constants.IF_ICMPGT:
					case Constants.IF_ICMPLE:
					case Constants.IF_ICMPLT:
					case Constants.IF_ICMPNE:
					case Constants.GOTO_W:
					case Constants.JSR_W:
						set.add(Integer.toString(Util.getSignedNum(op.operands[0]) + op.offset));
						break;

					}
				}
				if (code.exception_table_length != 0) {
					Attribute_Code.ExceptionTableItem[] exceptions = code.exception_table;
					Attribute_Code.ExceptionTableItem exc;
					for (int j = 0; j < exceptions.length; j++) {
						exc = exceptions[j];
						set.add(Integer.toString(exc.start_pc));
						set.add(Integer.toString(exc.end_pc));
						set.add(Integer.toString(exc.handler_pc));
					}
				}

				if (code.attributes_count != 0) {
					for (int j = 0; j < code.attributes_count; j++) {
						if (code.attributes[j].attribute_tag == Constants.ATTRIBUTE_LineNumberTable && config.showLineNumber == true) {
							Attribute_LineNumberTable lineNumberTable = (Attribute_LineNumberTable) code.attributes[j];
							Attribute_LineNumberTable.LineNumber[] lines = lineNumberTable.lineNumberTable;
							for (int x = 0; x < lineNumberTable.line_number_table_length; x++) {
								set.add(Integer.toString(lines[x].start_pc));
							}
						} else if (code.attributes[j].attribute_tag == Constants.ATTRIBUTE_LocalVariableTable) {
							Attribute_LocalVariableTable lvt = (Attribute_LocalVariableTable) code.attributes[j];
							if (lvt.local_variable_table_length != 0) {
								Attribute_LocalVariableTable.LocalVariable[] lvs = lvt.local_variable_table;
								Attribute_LocalVariableTable.LocalVariable lv;
								for (int x = 0; x < lvs.length; x++) {
									lv = lvs[x];
									set.add(Integer.toString(lv.start_pc));
									if (lv.length != 1) {
										op = findPreviousInstruction(lv.start_pc + lv.length, ops);
										if (op != null) {
											set.add(Integer.toString(op.offset));
										}
									}
								}
							}
						}
					}
				}
				break;
			}
		}
		return set;
	}

	/**
	 * given an offset, and a series of instructions, find the first instruction
	 * that is before the given offset
	 * 
	 * @param offset
	 * @param ops
	 * @return
	 */
	private Attribute_Code.Opcode findPreviousInstruction(int offset, Attribute_Code.Opcode[] ops) {
		for (int i = ops.length - 1; i > -1; i--) {
			if (ops[i].offset < offset) {
				return ops[i];
			}
		}
		return null;
	}

	public static String toString_Static(JavaClass clazz) {
		SourceCodeBuilder builder = new SourceCodeBuilder();
		return builder.toString(clazz);
	}

}","private String toString(Attribute_LineNumberTable attr) {
	if (attr.line_number_table_length == 0)
		return """";
	StringBuffer buf = new StringBuffer();
	buf.append(""["" + Constants.ATTRIBUTE_NAME_LINE_NUMBER_TABLE + "" :"");
	for (int i = 0; i < attr.line_number_table_length; i++) {
		buf.append(Constants.LINE_SEPARATER);
		buf.append(config.labelPrefix + attr.lineNumberTable[i].start_pc + "" ->  "" + attr.lineNumberTable[i].line_number);
	}
	buf.append(""]"");
	return buf.toString();
}",True,"
*** SOURCE CODE: BEGIN ***
private String toString(Attribute_LineNumberTable attr) {
	if (attr.line_number_table_length == 0)
		return """";
	StringBuffer buf = new StringBuffer();
	buf.append(""["" + Constants.ATTRIBUTE_NAME_LINE_NUMBER_TABLE + "" :"");
	for (int i = 0; i < attr.line_number_table_length; i++) {
		buf.append(Constants.LINE_SEPARATER);
		buf.append(config.labelPrefix + attr.lineNumberTable[i].start_pc + "" ->  "" + attr.lineNumberTable[i].line_number);
	}
	buf.append(""]"");
	return buf.toString();
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 0
ATFD_method = 7
FDP_method = 4
CM_method = 0
MAXNESTING_method = 2
LOC_method = 12
CYCLO_method = 3
NMCS_method = 0
NOLV_method = 3
MaMCL_method = 0
NOAV_method = 11
LAA_method = 0.125
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 1
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 0
NOCS_type = 0
NOM_type = 31
NMO_type = 0
ATFD_type = 173
FANOUT_type = 4
NOMNAMM_type = 31
NOA_type = 2
NIM_type = 0
DIT_type = 1
LOC_type = 828
LOCNAMM_type = 828
CFNAMM_type = 13
TCC_type = 1
NOPA_type = 0
CBO_type = 36
RFC_type = 44
NOC_type = 0
WMC_type = 213
LCOM5_type = 0.666666667
WOC_type = 1.0
WMCNAMM_type = 213
AMW_type = 6.870967742
AMWNAMM_type = 6.870967742
NOCS_package = 3
NOMNAMM_package = 54
NOI_package = 0
LOC_package = 1422
NOM_package = 54
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 0
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 2
num_final_attributes = 0
num_static_attributes = 0
number_public_visibility_methods = 4
number_private_visibility_methods = 27
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 31
number_static_methods = 1
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 1
number_not_final_not_static_methods = 30
number_standard_design_methods = 29
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 2
num_final_static_attributes = 0
num_not_final_not_static_attributes = 2
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",True
com.jasml.helper.IntegerArray,public int[] getAll(),0,1,0,0,2,1,5,1,0,1,0,3,1.0,0,0,2,0,0,0,0.0,0,1,0,3,0,0,0,2,4,0,1,27,20,0,1,0,0,3,0,4,0.75,0.666666667,3,1.333333333,1.5,5,33,0,943,34,4,48,1,245,233,6694,0,4,0,0,1,1,3,0,0,0,0,0,3,0,0,0,0,3,1,0,1,1,3,0,0,0,1,-1,1,0,"package com.jasml.helper;

public class IntegerArray {
	private int[] data;
	private int max;
	private int currentSize ;
	private final static int Increment = 10;
	public IntegerArray(int size){
		data = new int[size];
		max=size;
		currentSize =0;
	}
	public void add(int var){
		if(currentSize>=max){
			max = max+Increment;
			int[] ni = new int[max];
			System.arraycopy(data,0,ni,0,data.length);
			data = ni;
			ni = null;
		}
		data[currentSize++]=var;
	}
	public int[] getAll(){
		int[] ret = new int[currentSize];
		System.arraycopy(data,0,ret,0,currentSize);
		return ret;
	}
	
}
","public int[] getAll(){
	int[] ret = new int[currentSize];
	System.arraycopy(data,0,ret,0,currentSize);
	return ret;
}",False,"
*** SOURCE CODE: BEGIN ***
public int[] getAll(){
	int[] ret = new int[currentSize];
	System.arraycopy(data,0,ret,0,currentSize);
	return ret;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 0
CC_method = 1
ATFD_method = 0
FDP_method = 0
CM_method = 2
MAXNESTING_method = 1
LOC_method = 5
CYCLO_method = 1
NMCS_method = 0
NOLV_method = 1
MaMCL_method = 0
NOAV_method = 3
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 2
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 3
NMO_type = 0
ATFD_type = 0
FANOUT_type = 0
NOMNAMM_type = 2
NOA_type = 4
NIM_type = 0
DIT_type = 1
LOC_type = 27
LOCNAMM_type = 20
CFNAMM_type = 0
TCC_type = 1
NOPA_type = 0
CBO_type = 0
RFC_type = 3
NOC_type = 0
WMC_type = 4
LCOM5_type = 0.75
WOC_type = 0.666666667
WMCNAMM_type = 3
AMW_type = 1.333333333
AMWNAMM_type = 1.5
NOCS_package = 5
NOMNAMM_package = 33
NOI_package = 0
LOC_package = 943
NOM_package = 34
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 4
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 1
num_static_attributes = 1
number_public_visibility_methods = 3
number_private_visibility_methods = 0
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 3
number_static_methods = 0
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 0
number_not_final_not_static_methods = 3
number_standard_design_methods = 1
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 1
num_not_final_not_static_attributes = 3
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",False
com.jasml.helper.IntegerArray,public void add(int var),1,1,0,0,2,2,10,2,0,2,0,6,1.0,0,0,4,0,0,0,0.0,0,1,0,3,0,0,0,2,4,0,1,27,20,0,1,0,0,3,0,4,0.75,0.666666667,3,1.333333333,1.5,5,33,0,943,34,4,48,1,245,233,6694,0,4,0,0,1,1,3,0,0,0,0,0,3,0,0,0,0,3,1,0,1,1,3,0,0,0,2,2,0,2,"package com.jasml.helper;

public class IntegerArray {
	private int[] data;
	private int max;
	private int currentSize ;
	private final static int Increment = 10;
	public IntegerArray(int size){
		data = new int[size];
		max=size;
		currentSize =0;
	}
	public void add(int var){
		if(currentSize>=max){
			max = max+Increment;
			int[] ni = new int[max];
			System.arraycopy(data,0,ni,0,data.length);
			data = ni;
			ni = null;
		}
		data[currentSize++]=var;
	}
	public int[] getAll(){
		int[] ret = new int[currentSize];
		System.arraycopy(data,0,ret,0,currentSize);
		return ret;
	}
	
}
","public void add(int var){
	if(currentSize>=max){
		max = max+Increment;
		int[] ni = new int[max];
		System.arraycopy(data,0,ni,0,data.length);
		data = ni;
		ni = null;
	}
	data[currentSize++]=var;
}",True,"
*** SOURCE CODE: BEGIN ***
public void add(int var){
	if(currentSize>=max){
		max = max+Increment;
		int[] ni = new int[max];
		System.arraycopy(data,0,ni,0,data.length);
		data = ni;
		ni = null;
	}
	data[currentSize++]=var;
}
*** SOURCE CODE: END ***

*** METRICS: BEGIN ***
NOP_method = 1
CC_method = 1
ATFD_method = 0
FDP_method = 0
CM_method = 2
MAXNESTING_method = 2
LOC_method = 10
CYCLO_method = 2
NMCS_method = 0
NOLV_method = 2
MaMCL_method = 0
NOAV_method = 6
LAA_method = 1.0
FANOUT_method = 0
CFNAMM_method = 0
ATLD_method = 4
CLNAMM_method = 0
CINT_method = 0
MeMCL_method = 0
CDISP_method = 0.0
NOII_type = 0
NOAM_type = 1
NOCS_type = 0
NOM_type = 3
NMO_type = 0
ATFD_type = 0
FANOUT_type = 0
NOMNAMM_type = 2
NOA_type = 4
NIM_type = 0
DIT_type = 1
LOC_type = 27
LOCNAMM_type = 20
CFNAMM_type = 0
TCC_type = 1
NOPA_type = 0
CBO_type = 0
RFC_type = 3
NOC_type = 0
WMC_type = 4
LCOM5_type = 0.75
WOC_type = 0.666666667
WMCNAMM_type = 3
AMW_type = 1.333333333
AMWNAMM_type = 1.5
NOCS_package = 5
NOMNAMM_package = 33
NOI_package = 0
LOC_package = 943
NOM_package = 34
NOPK_project = 4
NOCS_project = 48
NOI_project = 1
NOM_project = 245
NOMNAMM_project = 233
LOC_project = 6694
isStatic_type = 0
number_private_visibility_attributes = 4
number_protected_visibility_attributes = 0
number_package_visibility_attributes = 0
num_final_attributes = 1
num_static_attributes = 1
number_public_visibility_methods = 3
number_private_visibility_methods = 0
number_protected_visibility_methods = 0
number_package_visibility_methods = 0
number_final_methods = 0
number_abstract_methods = 0
number_not_abstract_not_final_methods = 3
number_static_methods = 0
number_final_static_methods = 0
number_final_not_static_methods = 0
number_not_final_static_methods = 0
number_not_final_not_static_methods = 3
number_standard_design_methods = 1
number_constructor_DefaultConstructor_methods = 0
number_constructor_NotDefaultConstructor_methods = 1
num_final_static_attributes = 1
num_not_final_not_static_attributes = 3
num_final_not_static_attributes = 0
num_static_not_final_attributes = 0
isStatic_method = 0

*** METRICS: END ***
",False
